<!DOCTYPE html>

<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="mobile-web-app-capable" content="yes">
    <title>
        Chương 14 - HackMD
    </title>
    <link rel="icon" type="image/png" href="https://hackmd.io/favicon.png">
    <link rel="apple-touch-icon" href="https://hackmd.io/apple-touch-icon.png">

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha256-916EbMg70RQy9LHiGkXzG8hSg9EdNy97GazNG/aiY1w=" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha256-eZrrJcwDc/3uDhsdt61sL2oOBY362qM3lon1gyExkL0=" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/ionicons/2.0.1/css/ionicons.min.css" integrity="sha256-3iu9jgsy9TpTwXKb7bNQzqWekRX7pPK+2OLj3R922fo=" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/octicons/3.5.0/octicons.min.css" integrity="sha256-QiWfLIsCT02Sdwkogf6YMiQlj4NE84MKkzEMkZnMGdg=" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.1/themes/prism.min.css" integrity="sha256-vtR0hSWRc3Tb26iuN2oZHt3KRUomwTufNIf5/4oeCyg=" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/emojify.js/1.1.0/css/basic/emojify.min.css" integrity="sha256-UOrvMOsSDSrW6szVLe8ZDZezBxh5IoIfgTwdNDgTjiU=" crossorigin="anonymous" />
    <style>
        @import url(https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,500,500i|Source+Code+Pro:300,400,500|Source+Sans+Pro:300,300i,400,400i,600,600i|Source+Serif+Pro&subset=latin-ext);.hljs{display:block;background:#fff;padding:.5em;color:#333;overflow-x:auto}.hljs-comment,.hljs-meta{color:#969896}.hljs-emphasis,.hljs-quote,.hljs-string,.hljs-strong,.hljs-template-variable,.hljs-variable{color:#df5000}.hljs-keyword,.hljs-selector-tag,.hljs-type{color:#a71d5d}.hljs-attribute,.hljs-bullet,.hljs-literal,.hljs-number,.hljs-symbol{color:#0086b3}.hljs-built_in,.hljs-builtin-name{color:#005cc5}.hljs-name,.hljs-section{color:#63a35c}.hljs-tag{color:#333}.hljs-attr,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-id,.hljs-selector-pseudo,.hljs-title{color:#795da3}.hljs-addition{color:#55a532;background-color:#eaffea}.hljs-deletion{color:#bd2c00;background-color:#ffecec}.hljs-link{text-decoration:underline}.markdown-body{font-size:16px;line-height:1.5;word-wrap:break-word}.markdown-body:after,.markdown-body:before{display:table;content:""}.markdown-body:after{clear:both}.markdown-body>:first-child{margin-top:0!important}.markdown-body>:last-child{margin-bottom:0!important}.markdown-body a:not([href]){color:inherit;text-decoration:none}.markdown-body .absent{color:#c00}.markdown-body .anchor{float:left;padding-right:4px;margin-left:-20px;line-height:1}.markdown-body .anchor:focus{outline:none}.markdown-body blockquote,.markdown-body dl,.markdown-body ol,.markdown-body p,.markdown-body pre,.markdown-body table,.markdown-body ul{margin-top:0;margin-bottom:16px}.markdown-body hr{height:.25em;padding:0;margin:24px 0;background-color:#e7e7e7;border:0}.markdown-body blockquote{font-size:16px;padding:0 1em;color:#777;border-left:.25em solid #ddd}.markdown-body blockquote>:first-child{margin-top:0}.markdown-body blockquote>:last-child{margin-bottom:0}.markdown-body .loweralpha{list-style-type:lower-alpha}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{margin-top:24px;margin-bottom:16px;font-weight:600;line-height:1.25}.markdown-body h1 .octicon-link,.markdown-body h2 .octicon-link,.markdown-body h3 .octicon-link,.markdown-body h4 .octicon-link,.markdown-body h5 .octicon-link,.markdown-body h6 .octicon-link{color:#000;vertical-align:middle;visibility:hidden}.markdown-body h1:hover .anchor,.markdown-body h2:hover .anchor,.markdown-body h3:hover .anchor,.markdown-body h4:hover .anchor,.markdown-body h5:hover .anchor,.markdown-body h6:hover .anchor{text-decoration:none}.markdown-body h1:hover .anchor .octicon-link,.markdown-body h2:hover .anchor .octicon-link,.markdown-body h3:hover .anchor .octicon-link,.markdown-body h4:hover .anchor .octicon-link,.markdown-body h5:hover .anchor .octicon-link,.markdown-body h6:hover .anchor .octicon-link{visibility:visible}.markdown-body h1 code,.markdown-body h1 tt,.markdown-body h2 code,.markdown-body h2 tt,.markdown-body h3 code,.markdown-body h3 tt,.markdown-body h4 code,.markdown-body h4 tt,.markdown-body h5 code,.markdown-body h5 tt,.markdown-body h6 code,.markdown-body h6 tt{font-size:inherit}.markdown-body h1{font-size:2em}.markdown-body h1,.markdown-body h2{padding-bottom:.3em;border-bottom:1px solid #eee}.markdown-body h2{font-size:1.5em}.markdown-body h3{font-size:1.25em}.markdown-body h4{font-size:1em}.markdown-body h5{font-size:.875em}.markdown-body h6{font-size:.85em;color:#777}.markdown-body ol,.markdown-body ul{padding-left:2em}.markdown-body ol.no-list,.markdown-body ul.no-list{padding:0;list-style-type:none}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:0;margin-bottom:0}.markdown-body li>p{margin-top:16px}.markdown-body li+li{margin-top:.25em}.markdown-body dl{padding:0}.markdown-body dl dt{padding:0;margin-top:16px;font-size:1em;font-style:italic;font-weight:700}.markdown-body dl dd{padding:0 16px;margin-bottom:16px}.markdown-body table{display:block;width:100%;overflow:auto;word-break:normal;word-break:keep-all}.markdown-body table th{font-weight:700}.markdown-body table td,.markdown-body table th{padding:6px 13px;border:1px solid #ddd}.markdown-body table tr{background-color:#fff;border-top:1px solid #ccc}.markdown-body table tr:nth-child(2n){background-color:#f8f8f8}.markdown-body img{max-width:100%;box-sizing:content-box;background-color:#fff}.markdown-body img[align=right]{padding-left:20px}.markdown-body img[align=left]{padding-right:20px}.markdown-body .emoji{max-width:none;vertical-align:text-top;background-color:transparent}.markdown-body span.frame{display:block;overflow:hidden}.markdown-body span.frame>span{display:block;float:left;width:auto;padding:7px;margin:13px 0 0;overflow:hidden;border:1px solid #ddd}.markdown-body span.frame span img{display:block;float:left}.markdown-body span.frame span span{display:block;padding:5px 0 0;clear:both;color:#333}.markdown-body span.align-center{display:block;overflow:hidden;clear:both}.markdown-body span.align-center>span{display:block;margin:13px auto 0;overflow:hidden;text-align:center}.markdown-body span.align-center span img{margin:0 auto;text-align:center}.markdown-body span.align-right{display:block;overflow:hidden;clear:both}.markdown-body span.align-right>span{display:block;margin:13px 0 0;overflow:hidden;text-align:right}.markdown-body span.align-right span img{margin:0;text-align:right}.markdown-body span.float-left{display:block;float:left;margin-right:13px;overflow:hidden}.markdown-body span.float-left span{margin:13px 0 0}.markdown-body span.float-right{display:block;float:right;margin-left:13px;overflow:hidden}.markdown-body span.float-right>span{display:block;margin:13px auto 0;overflow:hidden;text-align:right}.markdown-body code,.markdown-body tt{padding:0;padding-top:.2em;padding-bottom:.2em;margin:0;font-size:85%;background-color:rgba(0,0,0,.04);border-radius:3px}.markdown-body code:after,.markdown-body code:before,.markdown-body tt:after,.markdown-body tt:before{letter-spacing:-.2em;content:"\00a0"}.markdown-body code br,.markdown-body tt br{display:none}.markdown-body del code{text-decoration:inherit}.markdown-body pre{word-wrap:normal}.markdown-body pre>code{padding:0;margin:0;font-size:100%;word-break:normal;white-space:pre;background:transparent;border:0}.markdown-body .highlight{margin-bottom:16px}.markdown-body .highlight pre{margin-bottom:0;word-break:normal}.markdown-body .highlight pre,.markdown-body pre{padding:16px;overflow:auto;font-size:85%;line-height:1.45;background-color:#f7f7f7;border-radius:3px}.markdown-body pre code,.markdown-body pre tt{display:inline;max-width:auto;padding:0;margin:0;overflow:visible;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}.markdown-body pre code:after,.markdown-body pre code:before,.markdown-body pre tt:after,.markdown-body pre tt:before{content:normal}.markdown-body .csv-data td,.markdown-body .csv-data th{padding:5px;overflow:hidden;font-size:12px;line-height:1;text-align:left;white-space:nowrap}.markdown-body .csv-data .blob-line-num{padding:10px 8px 9px;text-align:right;background:#fff;border:0}.markdown-body .csv-data tr{border-top:0}.markdown-body .csv-data th{font-weight:700;background:#f8f8f8;border-top:0}.markdown-body kbd{display:inline-block;padding:3px 5px;font-size:11px;line-height:10px;color:#555;vertical-align:middle;background-color:#fcfcfc;border:1px solid #ccc;border-bottom-color:#bbb;border-radius:3px;box-shadow:inset 0 -1px 0 #bbb}.news .alert .markdown-body blockquote{padding:0 0 0 40px;border:0 none}.activity-tab .news .alert .commits,.activity-tab .news .markdown-body blockquote{padding-left:0}.task-list-item{list-style-type:none}.task-list-item label{font-weight:400}.task-list-item.enabled label{cursor:pointer}.task-list-item+.task-list-item{margin-top:3px}.task-list-item-checkbox{float:left;margin:.31em 0 .2em -1.3em!important;vertical-align:middle;cursor:default!important}.markdown-body{font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Helvetica Neue,Helvetica,Roboto,Arial,sans-serif;padding-top:40px;padding-bottom:40px;max-width:758px;overflow:visible!important}.markdown-body .emoji{vertical-align:top}.markdown-body pre{border:inherit!important}.markdown-body code{color:inherit!important}.markdown-body pre code .wrapper{display:-moz-inline-flex;display:-ms-inline-flex;display:-o-inline-flex;display:inline-flex}.markdown-body pre code .gutter{float:left;overflow:hidden;-webkit-user-select:none;user-select:none}.markdown-body pre code .gutter.linenumber{text-align:right;position:relative;display:inline-block;cursor:default;z-index:4;padding:0 8px 0 0;min-width:20px;box-sizing:content-box;color:#afafaf!important;border-right:3px solid #6ce26c!important}.markdown-body pre code .gutter.linenumber>span:before{content:attr(data-linenumber)}.markdown-body pre code .code{float:left;margin:0 0 0 16px}.markdown-body .gist .line-numbers{border-left:none;border-top:none;border-bottom:none}.markdown-body .gist .line-data{border:none}.markdown-body .gist table{border-spacing:0;border-collapse:inherit!important}.markdown-body code[data-gist-id]{background:none;padding:0}.markdown-body code[data-gist-id]:after,.markdown-body code[data-gist-id]:before{content:""}.markdown-body code[data-gist-id] .blob-num{border:unset}.markdown-body code[data-gist-id] table{overflow:unset;margin-bottom:unset}.markdown-body code[data-gist-id] table tr{background:unset}.markdown-body[dir=rtl] pre{direction:ltr}.markdown-body[dir=rtl] code{direction:ltr;unicode-bidi:embed}.markdown-body .alert>p{margin-bottom:0}.markdown-body pre.abc,.markdown-body pre.flow-chart,.markdown-body pre.graphviz,.markdown-body pre.mermaid,.markdown-body pre.sequence-diagram{text-align:center;background-color:inherit;border-radius:0;white-space:inherit}.markdown-body pre.abc>code,.markdown-body pre.flow-chart>code,.markdown-body pre.graphviz>code,.markdown-body pre.mermaid>code,.markdown-body pre.sequence-diagram>code{text-align:left}.markdown-body pre.abc>svg,.markdown-body pre.flow-chart>svg,.markdown-body pre.graphviz>svg,.markdown-body pre.mermaid>svg,.markdown-body pre.sequence-diagram>svg{max-width:100%;height:100%}.markdown-body pre>code.wrap{white-space:pre-wrap;white-space:-moz-pre-wrap;white-space:-pre-wrap;white-space:-o-pre-wrap;word-wrap:break-word}.markdown-body .alert>p,.markdown-body .alert>ul{margin-bottom:0}.markdown-body summary{display:list-item}.markdown-body summary:focus{outline:none}.markdown-body details summary{cursor:pointer}.markdown-body details:not([open])>:not(summary){display:none}.markdown-body figure{margin:1em 40px}.markdown-body .mark,.markdown-body mark{background-color:#fff1a7}.vimeo,.youtube{cursor:pointer;display:table;text-align:center;background-position:50%;background-repeat:no-repeat;background-size:contain;background-color:#000;overflow:hidden}.vimeo,.youtube{position:relative;width:100%}.youtube{padding-bottom:56.25%}.vimeo img{width:100%;object-fit:contain;z-index:0}.youtube img{object-fit:cover;z-index:0}.vimeo iframe,.youtube iframe,.youtube img{width:100%;height:100%;position:absolute;top:0;left:0}.vimeo iframe,.youtube iframe{vertical-align:middle;z-index:1}.vimeo .icon,.youtube .icon{position:absolute;height:auto;width:auto;top:50%;left:50%;transform:translate(-50%,-50%);color:#fff;opacity:.3;transition:opacity .2s;z-index:0}.vimeo:hover .icon,.youtube:hover .icon{opacity:.6;transition:opacity .2s}.slideshare .inner,.speakerdeck .inner{position:relative;width:100%}.slideshare .inner iframe,.speakerdeck .inner iframe{position:absolute;top:0;bottom:0;left:0;right:0;width:100%;height:100%}.MJX_Assistive_MathML{display:none}.ui-infobar{position:relative;z-index:2;max-width:760px;margin:25px auto -25px;padding:0 15px;color:#777}.toc .invisable-node{list-style-type:none}.ui-toc{position:fixed;bottom:20px;z-index:998}.ui-toc-label{opacity:.3;background-color:#ccc;border:none;transition:opacity .2s}.ui-toc .open .ui-toc-label{opacity:1;color:#fff;transition:opacity .2s}.ui-toc-label:focus{opacity:.3;background-color:#ccc;color:#000}.ui-toc-label:hover{opacity:1;background-color:#ccc;transition:opacity .2s}.ui-toc-dropdown{margin-top:23px;margin-bottom:20px;padding-left:10px;padding-right:10px;max-width:45vw;width:25vw;max-height:70vh;overflow:auto;text-align:inherit}.ui-toc-dropdown>.toc{max-height:calc(70vh - 100px);overflow:auto}.ui-toc-dropdown[dir=rtl] .nav{padding-right:0;letter-spacing:.0029em}.ui-toc-dropdown a{overflow:hidden;text-overflow:ellipsis;white-space:pre}.ui-toc-dropdown .nav>li>a{display:block;padding:4px 20px;font-size:13px;font-weight:500;color:#767676}.ui-toc-dropdown .nav>li:first-child:last-child > ul,.ui-toc-dropdown .toc.expand ul{display:block}.ui-toc-dropdown .nav>li>a:focus,.ui-toc-dropdown .nav>li>a:hover{padding-left:19px;color:#000;text-decoration:none;background-color:transparent;border-left:1px solid #000}.ui-toc-dropdown[dir=rtl] .nav>li>a:focus,.ui-toc-dropdown[dir=rtl] .nav>li>a:hover{padding-right:19px;border-left:none;border-right:1px solid #000}.ui-toc-dropdown .nav>.active:focus>a,.ui-toc-dropdown .nav>.active:hover>a,.ui-toc-dropdown .nav>.active>a{padding-left:18px;font-weight:700;color:#000;background-color:transparent;border-left:2px solid #000}.ui-toc-dropdown[dir=rtl] .nav>.active:focus>a,.ui-toc-dropdown[dir=rtl] .nav>.active:hover>a,.ui-toc-dropdown[dir=rtl] .nav>.active>a{padding-right:18px;border-left:none;border-right:2px solid #000}.ui-toc-dropdown .nav .nav{display:none;padding-bottom:10px}.ui-toc-dropdown .nav>.active>ul{display:block}.ui-toc-dropdown .nav .nav>li>a{padding-top:1px;padding-bottom:1px;padding-left:30px;font-size:12px;font-weight:400}.ui-toc-dropdown[dir=rtl] .nav .nav>li>a{padding-right:30px}.ui-toc-dropdown .nav .nav>li>ul>li>a{padding-top:1px;padding-bottom:1px;padding-left:40px;font-size:12px;font-weight:400}.ui-toc-dropdown[dir=rtl] .nav .nav>li>ul>li>a{padding-right:40px}.ui-toc-dropdown .nav .nav>li>a:focus,.ui-toc-dropdown .nav .nav>li>a:hover{padding-left:29px}.ui-toc-dropdown[dir=rtl] .nav .nav>li>a:focus,.ui-toc-dropdown[dir=rtl] .nav .nav>li>a:hover{padding-right:29px}.ui-toc-dropdown .nav .nav>li>ul>li>a:focus,.ui-toc-dropdown .nav .nav>li>ul>li>a:hover{padding-left:39px}.ui-toc-dropdown[dir=rtl] .nav .nav>li>ul>li>a:focus,.ui-toc-dropdown[dir=rtl] .nav .nav>li>ul>li>a:hover{padding-right:39px}.ui-toc-dropdown .nav .nav>.active:focus>a,.ui-toc-dropdown .nav .nav>.active:hover>a,.ui-toc-dropdown .nav .nav>.active>a{padding-left:28px;font-weight:500}.ui-toc-dropdown[dir=rtl] .nav .nav>.active:focus>a,.ui-toc-dropdown[dir=rtl] .nav .nav>.active:hover>a,.ui-toc-dropdown[dir=rtl] .nav .nav>.active>a{padding-right:28px}.ui-toc-dropdown .nav .nav>.active>.nav>.active:focus>a,.ui-toc-dropdown .nav .nav>.active>.nav>.active:hover>a,.ui-toc-dropdown .nav .nav>.active>.nav>.active>a{padding-left:38px;font-weight:500}.ui-toc-dropdown[dir=rtl] .nav .nav>.active>.nav>.active:focus>a,.ui-toc-dropdown[dir=rtl] .nav .nav>.active>.nav>.active:hover>a,.ui-toc-dropdown[dir=rtl] .nav .nav>.active>.nav>.active>a{padding-right:38px}.markdown-body[lang^=ja]{font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Helvetica Neue,Helvetica,Roboto,Arial,Hiragino Kaku Gothic Pro,ヒラギノ角ゴ Pro W3,Osaka,Meiryo,メイリオ,MS Gothic,ＭＳ\ ゴシック,sans-serif}.ui-toc-dropdown[lang^=ja]{font-family:Source Sans Pro,Helvetica,Arial,Meiryo UI,MS PGothic,ＭＳ\ Ｐゴシック,sans-serif}.markdown-body[lang=zh-tw]{font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Helvetica Neue,Helvetica,Roboto,Arial,PingFang TC,Microsoft JhengHei,微軟正黑,sans-serif}.ui-toc-dropdown[lang=zh-tw]{font-family:Source Sans Pro,Helvetica,Arial,Microsoft JhengHei UI,微軟正黑UI,sans-serif}.markdown-body[lang=zh-cn]{font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Helvetica Neue,Helvetica,Roboto,Arial,PingFang SC,Microsoft YaHei,微软雅黑,sans-serif}.ui-toc-dropdown[lang=zh-cn]{font-family:Source Sans Pro,Helvetica,Arial,Microsoft YaHei UI,微软雅黑UI,sans-serif}.ui-affix-toc{position:fixed;top:0;max-width:15vw;max-height:70vh;overflow:auto}.back-to-top,.expand-toggle,.go-to-bottom{display:block;padding:4px 10px;margin-top:10px;margin-left:10px;font-size:12px;font-weight:500;color:#999}.back-to-top:focus,.back-to-top:hover,.expand-toggle:focus,.expand-toggle:hover,.go-to-bottom:focus,.go-to-bottom:hover{color:#563d7c;text-decoration:none}.back-to-top,.go-to-bottom{margin-top:0}.ui-user-icon{width:20px;height:20px;display:block;border-radius:3px;margin-top:2px;margin-bottom:2px;margin-right:5px;background-position:50%;background-repeat:no-repeat;background-size:cover}.ui-user-icon.small{width:18px;height:18px;display:inline-block;vertical-align:middle;margin:0 0 .2em}.ui-infobar>small>span{line-height:22px}.ui-infobar>small .dropdown{display:inline-block}.ui-infobar>small .dropdown a:focus,.ui-infobar>small .dropdown a:hover{text-decoration:none}.unselectable{-webkit-user-select:none;-o-user-select:none;user-select:none}@media print{blockquote,div,img,pre,table{page-break-inside:avoid!important}a[href]:after{font-size:12px!important}}.markdown-body.slides{position:relative;z-index:1;color:#222}.markdown-body.slides:before{content:"";display:block;position:absolute;top:0;left:0;right:0;bottom:0;z-index:-1;background-color:currentColor;box-shadow:0 0 0 50vw}.markdown-body.slides section[data-markdown]{position:relative;margin-bottom:1.5em;background-color:#fff;text-align:center}.markdown-body.slides section[data-markdown] code{text-align:left}.markdown-body.slides section[data-markdown]:before{content:"";display:block;padding-bottom:56.23%}.markdown-body.slides section[data-markdown]>div:first-child{position:absolute;top:50%;left:1em;right:1em;transform:translateY(-50%);max-height:100%;overflow:hidden}.markdown-body.slides section[data-markdown]>ul{display:inline-block}.markdown-body.slides>section>section+section:after{content:"";position:absolute;top:-1.5em;right:1em;height:1.5em;border:3px solid #777}body{font-smoothing:subpixel-antialiased!important;-webkit-font-smoothing:subpixel-antialiased!important;-moz-osx-font-smoothing:auto!important;text-shadow:0 0 1em transparent,1px 1px 1.2px rgba(0,0,0,.004);-webkit-overflow-scrolling:touch;font-family:Source Sans Pro,Helvetica,Arial,sans-serif;letter-spacing:.025em}.focus,:focus{outline:none!important}::-moz-focus-inner{border:0!important}body.modal-open{overflow-y:auto;padding-right:0!important}
    </style>
    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    	<script src="https://cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv.min.js" integrity="sha256-3Jy/GbSLrg0o9y5Z5n1uw0qxZECH7C6OQpVBgNFYa0g=" crossorigin="anonymous"></script>
    	<script src="https://cdnjs.cloudflare.com/ajax/libs/respond.js/1.4.2/respond.min.js" integrity="sha256-g6iAfvZp+nDQ2TdTR/VVKJf3bGro4ub5fvWSWVRi2NE=" crossorigin="anonymous"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/es5-shim/4.5.9/es5-shim.min.js" integrity="sha256-8E4Is26QH0bD52WoQpcB+R/tcWQtpzlCojrybUd7Mxo=" crossorigin="anonymous"></script>
    <![endif]-->
</head>

<body>
    <div id="doc" class="markdown-body container-fluid comment-enabled"><h1 id="Chương-14"><a class="anchor hidden-xs" href="#Chương-14" title="Chương-14"><span class="octicon octicon-link"></span></a>Chương 14</h1><h1 id="Chương-14-Bộ-tự-mã-hóa"><a class="anchor hidden-xs" href="#Chương-14-Bộ-tự-mã-hóa" title="Chương-14-Bộ-tự-mã-hóa"><span class="octicon octicon-link"></span></a><center>Chương 14<br>
Bộ tự mã hóa</center></h1><blockquote>
<p><em><strong>ND</strong></em>: <em>Những phần có ghi <strong>ND</strong> là chú giải thêm của người dịch</em></p>
</blockquote><h1 id="Chapter-14-Bộ-tự-mã-hóa"><a class="anchor hidden-xs" href="#Chapter-14-Bộ-tự-mã-hóa" title="Chapter-14-Bộ-tự-mã-hóa"><span class="octicon octicon-link"></span></a>Chapter 14: Bộ tự mã hóa</h1><hr><hr><p>---------------<br>
Thuấn bắt đầu dịch từ đây (trang 499-503)<br>
---------------</p><p>Một <em>bộ tự mã hóa</em> (Autoencoder) là một mạng neuron được huấn luyện để cố gắng sao chép đầu vào của nó tới đầu ra. Phía bên trong mạng này có một tầng ẩn <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-2">h</span></span></span><script type="math/tex" id="MathJax-Element-1">\boldsymbol h</script></span> mô tả một đoạn <em><strong>mã</strong></em> (code) dùng để biểu diễn đầu vào. Cấu tạo của mạng bao gồm hai phần: một hàm mã hóa <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-3"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-4">h</span><span class="MJXp-mo" id="MJXp-Span-5" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mrow" id="MJXp-Span-6"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-7">f</span></span><span class="MJXp-mo" id="MJXp-Span-8" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-9">x</span><span class="MJXp-mo" id="MJXp-Span-10" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-2">\boldsymbol h = \mathcal{f}(\boldsymbol x)</script></span>, và một hàm giải mã có nhiệm vụ tái thiết đầu vào <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-11"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-12">r</span><span class="MJXp-mo" id="MJXp-Span-13" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mrow" id="MJXp-Span-14"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-15">g</span></span><span class="MJXp-mo" id="MJXp-Span-16" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-17">h</span><span class="MJXp-mo" id="MJXp-Span-18" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-3">\boldsymbol r = \mathcal g(\boldsymbol h)</script></span>. Cấu trúc này được thể hiện trong hình 14.1. Nếu một bộ tự mã hóa chỉ đơn giản là học để thu được <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-19"><span class="MJXp-mrow" id="MJXp-Span-20"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-21">g</span></span><span class="MJXp-mo" id="MJXp-Span-22" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mrow" id="MJXp-Span-23"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-24">f</span></span><span class="MJXp-mo" id="MJXp-Span-25" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-26">x</span><span class="MJXp-mo" id="MJXp-Span-27" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-28" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-29" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-30">x</span></span></span><script type="math/tex" id="MathJax-Element-4">\mathcal g(\mathcal f(\boldsymbol x)) = \boldsymbol x</script></span> tại mọi điểm, thì nó cũng không quá hữu dụng. Thay vào đó, các bộ tự mã hóa được thiết kế để chúng không thể học để sao chép một cách hoàn toàn. Chúng thường bị giới hạn bởi những phương pháp chỉ cho phép sao chép ở mức xấp xỉ, và chỉ sao chép những đầu vào giống với dữ liệu huấn luyện. Mô hình thường sẽ học được những thuộc tính hữu ích của dữ liệu, vì nó buộc phải ưu tiên những khía cạnh sẽ được sao chép của đầu vào.</p><p>Các bộ tự mã hóa hiện đại đã khái quát hóa ý tưởng về một bộ mã hóa và một bộ giải mã, vượt ra ngoài phạm vi của các hàm tất định thực hiện các phép ánh xạ ngẫu nhiên <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-31"><span class="MJXp-msubsup" id="MJXp-Span-32"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-33" style="margin-right: 0.05em;">p</span><span class="MJXp-mtext MJXp-script" id="MJXp-Span-34" style="vertical-align: -0.4em;">encoder</span></span><span class="MJXp-mo" id="MJXp-Span-35" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-36">h</span><span class="MJXp-mo" id="MJXp-Span-37" style="margin-left: 0.333em; margin-right: 0.333em;">∣</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-38">x</span><span class="MJXp-mo" id="MJXp-Span-39" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-5">p_\text{encoder} (\boldsymbol h \mid \boldsymbol x)</script></span> và <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-40"><span class="MJXp-msubsup" id="MJXp-Span-41"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-42" style="margin-right: 0.05em;">p</span><span class="MJXp-mtext MJXp-script" id="MJXp-Span-43" style="vertical-align: -0.4em;">decoder</span></span><span class="MJXp-mo" id="MJXp-Span-44" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-45">x</span><span class="MJXp-mo" id="MJXp-Span-46" style="margin-left: 0.333em; margin-right: 0.333em;">∣</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-47">h</span><span class="MJXp-mo" id="MJXp-Span-48" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-6">p_\text {decoder}(\boldsymbol x \mid \boldsymbol h)</script></span>.</p><p>Ý tưởng về bộ tự mã hóa đã trở thành một phần trong bối cảnh lịch sử của các mạng neuron trong nhiều thập kỉ [LeCun, 1987; Bourlard and Kamp, 1988; Hinton and Zemel, 1994]. Thông thường, các bộ tự mã hóa được sử dụng trong tác vụ <em>giảm chiều dữ liệu</em> (dimentional reduction) hoặc <em>học đặc trưng</em> (feature learning). Gần đây, các liên kết về mặt lý thuyết giữa bộ tự mã hóa và các mô hình biến tiềm ẩn đã đưa bộ tự mã hóa lên vị trí tiên phong trong các mô hình sinh dữ liệu, như chúng ta sẽ thấy ở chương 20. Bộ tự mã hóa có thể được xem như một mạng lan truyền thuận đặc biệt và có thể được huấn luyện bằng các kỹ thuật tương tự như với mạng lan truyền thuận thông thường, điển hình là <em>trượt gradient theo lô nhỏ</em> (minibatch gradient descent) với các gradient được tính bằng thuật toán lan truyền ngược. Tuy nhiên, không giống như các mạng lan truyền thuận thông thường, bộ tự mã hóa cũng có thể được huấn luyện bằng cách sử dụng <em>sự tuần hoàn</em> (recirculation) [Hinton and McClelland, 1988], một thuật toán học dựa trên việc so sánh những tín hiệu kích hoạt (activation) của mạng trên đầu vào gốc với tín hiệu kích hoạt trên các đầu vào đã được tái thiết. Sự tuần hoàn được đánh giá là hợp lý hơn về mặt sinh học so với lan truyền ngược, nhưng nó hiếm khi được sử dụng cho các ứng dụng học máy.</p><p><img src="https://i.imgur.com/gYXWTzQ.png" alt=""></p><blockquote>
<p>Hình 14.1: Cấu trúc chung của một bộ tự mã hóa, ánh xạ một đầu vào <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-49"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-50">x</span></span></span><script type="math/tex" id="MathJax-Element-7">\boldsymbol x</script></span> tới một đầu ra (gọi là điểm tái thiết) <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-51"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-52">r</span></span></span><script type="math/tex" id="MathJax-Element-8">\boldsymbol r</script></span> thông qua một biểu diễn nội tại, hay đoạn mã hóa <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-53"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-54">h</span></span></span><script type="math/tex" id="MathJax-Element-9">\boldsymbol h</script></span>. Bộ tự mã hóa có hai thành phần: bộ mã hóa <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-55"><span class="MJXp-mrow" id="MJXp-Span-56"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-57">f</span></span></span></span><script type="math/tex" id="MathJax-Element-10">\mathcal{f}</script></span> (ánh xạ từ <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-58"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-59">x</span></span></span><script type="math/tex" id="MathJax-Element-11">\boldsymbol x</script></span> tới <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-60"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-61">h</span></span></span><script type="math/tex" id="MathJax-Element-12">\boldsymbol h</script></span>) và bộ giải mã <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-62"><span class="MJXp-mrow" id="MJXp-Span-63"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-64">g</span></span></span></span><script type="math/tex" id="MathJax-Element-13">\mathcal{g}</script></span> (ánh xạ từ <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-65"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-66">h</span></span></span><script type="math/tex" id="MathJax-Element-14">\boldsymbol h</script></span> tới <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-67"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-68">r</span></span></span><script type="math/tex" id="MathJax-Element-15">\boldsymbol r</script></span>).</p>
</blockquote><h1 id="141-Các-bộ-tự-mã-hóa-dưới-mức"><a class="anchor hidden-xs" href="#141-Các-bộ-tự-mã-hóa-dưới-mức" title="141-Các-bộ-tự-mã-hóa-dưới-mức"><span class="octicon octicon-link"></span></a>14.1 Các bộ tự mã hóa dưới mức</h1><p>Sao chép đầu vào tới đầu ra thoạt nghe có vẻ là một công việc vô nghĩa, nhưng thường thì chúng ta không quan tâm đến đầu ra của bộ giải mã. Thay vào đó, ta hi vọng rằng việc huấn luyện bộ tự mã hóa để thực hiện tác vụ sao chép đầu vào sẽ khiến cho <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-69"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-70">h</span></span></span><script type="math/tex" id="MathJax-Element-16">\boldsymbol h</script></span> trích xuất được những thuộc tính hữu ích.</p><p>Một phương pháp để thu được các đặc trưng hữu ích từ bộ tự mã hóa là buộc <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-71"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-72">h</span></span></span><script type="math/tex" id="MathJax-Element-17">\boldsymbol h</script></span> phải có số chiều nhỏ hơn <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-73"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-74">x</span></span></span><script type="math/tex" id="MathJax-Element-18">\boldsymbol x</script></span>. Một bộ tự mã hóa với chiều của đoạn mã hóa nhỏ hơn chiều của đầu vào được gọi là <em><strong>dưới mức</strong></em> (undercomplete). Việc học một biểu diễn với số chiều nhỏ hơn buộc bộ tự mã hóa phải nắm bắt được những đặc trưng nổi bật nhất trong dữ liệu huấn luyện.</p><p>Quá trình học có thể được mô tả đơn giản là quá trình cực tiểu hóa một hàm mất mát<br>
<span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-75"><span class="MJXp-mtable" id="MJXp-Span-76"><span><span class="MJXp-mlabeledtr" id="MJXp-Span-77" style="vertical-align: baseline;"><span class="MJXp-mtd" id="MJXp-Span-78" style="text-align: right;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-79">L</span><span class="MJXp-mo" id="MJXp-Span-80" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-81">x</span><span class="MJXp-mo" id="MJXp-Span-82" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mrow" id="MJXp-Span-83"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-84">g</span></span><span class="MJXp-mo" id="MJXp-Span-85" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mrow" id="MJXp-Span-86"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-87">f</span></span><span class="MJXp-mo" id="MJXp-Span-88" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-89">x</span><span class="MJXp-mo" id="MJXp-Span-90" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-91" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-92" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-93" style="margin-left: 0em; margin-right: 0.222em;">,</span></span></span></span></span></span></span><script type="math/tex; mode=display" id="MathJax-Element-19">\begin{align}
 L(\boldsymbol x, \mathcal{g}(\mathcal{f}(\boldsymbol x))), 
 \tag{14.1}
\end{align}</script></span><br>
trong đó <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-94"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-95">L</span></span></span><script type="math/tex" id="MathJax-Element-20">L</script></span> là một hàm mất mát để phạt <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-96"><span class="MJXp-mrow" id="MJXp-Span-97"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-98">g</span></span><span class="MJXp-mo" id="MJXp-Span-99" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mrow" id="MJXp-Span-100"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-101">f</span></span><span class="MJXp-mo" id="MJXp-Span-102" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-103">x</span><span class="MJXp-mo" id="MJXp-Span-104" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-105" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-21">\mathcal{g}(\mathcal{f}(\boldsymbol x))</script></span> khi không giống với <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-106"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-107">x</span></span></span><script type="math/tex" id="MathJax-Element-22">\boldsymbol x</script></span>, có thể sử dụng trung bình bình phương sai số.</p><p>Khi bộ giải mã là tuyến tính và <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-108"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-109">L</span></span></span><script type="math/tex" id="MathJax-Element-23">L</script></span> là trung bình bình phương sai số, một bộ tự mã hóa dưới mức sẽ học cách mở rộng không gian con giống như phương pháp phân tích thành phần chính (PCA). Trong trường hợp này, một bộ tự mã hóa được huấn luyện để thực hiện tác vụ sao chép đã học được không gian con chính của dữ liệu huấn luyện như một hiệu ứng phụ.</p><p>Các bộ tự mã hóa với bộ mã hóa phi tuyến <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-110"><span class="MJXp-mrow" id="MJXp-Span-111"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-112">f</span></span></span></span><script type="math/tex" id="MathJax-Element-24">\mathcal{f}</script></span> và bộ giải mã phi tuyến <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-113"><span class="MJXp-mrow" id="MJXp-Span-114"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-115">g</span></span></span></span><script type="math/tex" id="MathJax-Element-25">\mathcal{g}</script></span> nhờ đó có thể học được sự tổng quát phi tuyến mạnh hơn so với PCA. Không may là nếu bộ mã hóa và bộ giải mã có dung lượng quá lớn, bộ tự mã hóa có thể học để thực hiện tác vụ sao chép mà không cần trích xuất bất kỳ thông tin hữu ích nào về phân phối của dữ liệu. Chẳng hạn, về lý thuyết, ta có thể cho rằng một bộ tự mã hóa với đoạn mã hóa một chiều, nhưng có một bộ mã hóa phi tuyến rất mạnh mẽ (theo nghĩa là có dung lượng lớn) sẽ học được cách biểu diễn mẫu huấn luyện <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-116"><span class="MJXp-msubsup" id="MJXp-Span-117"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-118" style="margin-right: 0.05em;">x</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-119" style="vertical-align: 0.5em;"><span class="MJXp-mo" id="MJXp-Span-120">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-121">i</span><span class="MJXp-mo" id="MJXp-Span-122">)</span></span></span></span></span><script type="math/tex" id="MathJax-Element-26">\boldsymbol x^{(i)}</script></span> với đoạn mã hóa là chỉ số <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-123"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-124">i</span></span></span><script type="math/tex" id="MathJax-Element-27">i</script></span>. Sau đó bộ giải mã có thể học cách ánh xạ các chỉ số nguyên này trở lại giá trị của mẫu huấn luyện cụ thể. Trường hợp này tuy không xảy ra trong thực tế, nhưng nó là một minh họa rõ ràng về việc một bộ tự mã hóa được huấn luyện cho tác vụ sao chép có thể sẽ thất bại trong việc học thông tin hữu ích của tập dữ liệu nếu dung lượng của bộ tự mã hóa là quá lớn.</p><h1 id="142-Bộ-tự-mã-hóa-có-kiểm-soát"><a class="anchor hidden-xs" href="#142-Bộ-tự-mã-hóa-có-kiểm-soát" title="142-Bộ-tự-mã-hóa-có-kiểm-soát"><span class="octicon octicon-link"></span></a>14.2 Bộ tự mã hóa có kiểm soát</h1><p>Bộ tự mã hóa dưới mức với số chiều mã hóa nhỏ hơn số chiều của đầu vào có thể học những đặc trưng nổi bật nhất trong phân phối của dữ liệu. Ta đã thấy rằng những bộ tự mã hóa sẽ thất bại trong việc học những đặc trưng hữu ích nếu bộ mã hóa và giải mã được cấp một dung lượng quá lớn.</p><p>Vấn đề tương tự cũng xảy ra trong trường hợp đoạn mã hóa có số chiều tương đương, hoặc lớn hơn số chiều của đầu vào như trong trường hợp <em><strong>vượt mức</strong></em> (overcomplete). Khi đó, ngay cả một bộ mã hóa tuyến tính và một bộ giải mã tuyến tính cũng có đủ khả năng để học cách sao chép đầu vào tới đầu ra, mà không cần học bất kỳ đặc tính hữu ích nào trong phân phối của dữ liệu.</p><p>Một cách lý tưởng, ta có thể huấn luyện thành công bất kì kiến trúc nào của bộ tự mã hóa, với số chiều mã hóa và dung lượng của bộ mã hóa cũng như bộ giải mã được chọn dựa trên độ phức tạp của phân phối mà ta mô hình hóa. Bộ tự mã hóa có cơ chế kiểm soát cho phép ta thực hiện điều này. Thay vì giới hạn dung lượng của mô hình bằng cách giới hạn số tầng của bộ mã hóa, bộ giải mã và số chiều mã hóa, bộ tự mã hóa có cơ chế kiểm soát dùng một hàm mất mát để khuyến khích mô hình có được những tính chất khác, bên cạnh khả năng sao chép đầu vào tới đầu ra của nó. Các tính chất khác này bao gồm tính thưa của biểu diễn, giá trị nhỏ của đạo hàm của biểu diễn, và sự ổn định đovới nhiễu hoặc sự thiếu đầu vào. Một bộ tự mã hóa có kiểm soát có thể là phi tuyến và vượt mức, nhưng vẫn có thể học một số thông tin hữu ích từ dữ liệu, ngay cả khi dung lượng của mô hình là rất lớn.</p><p>Ngoài các phương pháp được mô tả ở trên, gần như bất kì mô hình sinh mẫu nào có biến tiềm ẩn và được trang bị một tiến trình suy luận (để tính toán biểu diễn tiềm ẩn khi biết đầu vào) cũng có thể được coi như một dạng bộ tự mã hóa đặc biệt. Hai hướng tiếp cận với mô hình sinh mẫu giúp nhấn mạnh mối liên hệ nêu trên có nguồn gốc từ máy Helmholtz [Hinton et al, 1995b], đó là bộ tự mã hóa biến phân (phần 20.10.3) và các mạng sinh mẫu ngẫu nhiên (phần 20.12). Các mô hình này học những quá trình mã hóa vượt mức và có dung lượng cao từ đầu vào một cách tự nhiên mà không yêu cầu cơ chế kiểm soát nào để có thể mã hóa một cách hiệu quả. Quá trình mã hóa của chúng mang lại hiệu quả một cách tự nhiên, bởi những mô hình này đã được huấn luyện để cực đại hóa xác suất của dữ liệu huấn luyện thay vì sao chép đầu vào tới đầu ra.</p><h2 id="1421-Bộ-tự-mã-hóa-thưa"><a class="anchor hidden-xs" href="#1421-Bộ-tự-mã-hóa-thưa" title="1421-Bộ-tự-mã-hóa-thưa"><span class="octicon octicon-link"></span></a>14.2.1 Bộ tự mã hóa thưa</h2><p>Một bộ tự mã hóa thưa đơn giản là một tự bộ mã hóa mà tiêu chuẩn huấn luyện của nó bao gồm một mức phạt thưa <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-125"><span class="MJXp-mi" id="MJXp-Span-126">Ω</span><span class="MJXp-mo" id="MJXp-Span-127" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-128">h</span><span class="MJXp-mo" id="MJXp-Span-129" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-28">\Omega(\boldsymbol h)</script></span> tại tầng mã hóa <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-130"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-131">h</span></span></span><script type="math/tex" id="MathJax-Element-29">\boldsymbol h</script></span> được thêm vào sai số tái thiết:</p><p><span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-132"><span class="MJXp-mtable" id="MJXp-Span-133"><span><span class="MJXp-mlabeledtr" id="MJXp-Span-134" style="vertical-align: baseline;"><span class="MJXp-mtd" id="MJXp-Span-135" style="text-align: right;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-136">L</span><span class="MJXp-mo" id="MJXp-Span-137" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-138">x</span><span class="MJXp-mo" id="MJXp-Span-139" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mrow" id="MJXp-Span-140"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-141">g</span></span><span class="MJXp-mo" id="MJXp-Span-142" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mrow" id="MJXp-Span-143"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-144">f</span></span><span class="MJXp-mo" id="MJXp-Span-145" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-146">x</span><span class="MJXp-mo" id="MJXp-Span-147" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-148" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-149" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-150" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mi" id="MJXp-Span-151">Ω</span><span class="MJXp-mo" id="MJXp-Span-152" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-153">h</span><span class="MJXp-mo" id="MJXp-Span-154" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-155" style="margin-left: 0em; margin-right: 0.222em;">,</span></span></span></span></span></span></span><script type="math/tex; mode=display" id="MathJax-Element-30">\begin{align}
L(\boldsymbol x, \mathcal{g}(\mathcal{f}(\boldsymbol x))) + \Omega(\boldsymbol h),
 \tag{14.2}
\end{align}</script></span><br>
trong đó <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-156"><span class="MJXp-mrow" id="MJXp-Span-157"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-158">g</span></span><span class="MJXp-mo" id="MJXp-Span-159" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-160">h</span><span class="MJXp-mo" id="MJXp-Span-161" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-31">\mathcal{g}(\boldsymbol h)</script></span> là đầu ra của bộ giải mã, và ta thường có đầu ra của bộ mã hóa là <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-162"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-163">h</span><span class="MJXp-mo" id="MJXp-Span-164" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mrow" id="MJXp-Span-165"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-166">f</span></span><span class="MJXp-mo" id="MJXp-Span-167" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-168">x</span><span class="MJXp-mo" id="MJXp-Span-169" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-32">\boldsymbol h = \mathcal{f}(\boldsymbol x)</script></span>.</p><p>Bộ tự mã hóa thưa thường được dùng để học các đặc trưng cho một tác vụ khác, chẳng hạn như phân lớp. Một bộ tự mã hóa có kiểm soát để trở thành dạng thưa phải phản hồi được đối với các đặc trưng thống kê đặc biệt của tập dữ liệu mà nó sử dụng để huấn luyện, thay vì chỉ đơn thuần hoạt động như một hàm đồng nhất. Với phương pháp này, quá trình huấn luyện để thực hiện tác vụ sao chép với một mức phạt thưa có thể sinh ra một mô hình có thể học các đặc trưng hữu ích.</p><p>Ta có thể coi mức phạt <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-170"><span class="MJXp-mi" id="MJXp-Span-171">Ω</span><span class="MJXp-mo" id="MJXp-Span-172" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-173">h</span><span class="MJXp-mo" id="MJXp-Span-174" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-33">\Omega(\boldsymbol h)</script></span> là một số hạng kiểm soát được thêm vào mạng lan truyền thuận với nhiệm vụ ban đầu là sao chép đầu vào tới đầu ra (có hàm mục đích học không giám sát) và có thể thực hiện một số tác vụ có giám sát (với mục tiêu học có giám sát) dựa trên những đặc trưng thưa đó. Không giống như những cơ chế kiểm soát khác như <em>suy giảm trọng số</em> (weight decay), không có một cách diễn giải tường minh theo hướng Bayes nào cho bộ kiểm soát này. Như mô tả trong phần 5.6.1, quá trình huấn luyện sử dụng suy giảm trọng số và các mức phạt kiểm soát khác có thể được diễn giải như một <em>xấp xỉ hậu nghiệm cực đại</em> (Maximum a posteriori approximation - MAP approximation) với suy luận Bayes và mức phạt được thêm vào ứng với một phân phối xác suất tiên nghiệm của các tham số mô hình. Theo quan điểm này, quá trình cực đại hóa hàm hợp lý có kiểm soát tương ứng với việc cực đại hóa <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-175"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-176">p</span><span class="MJXp-mo" id="MJXp-Span-177" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-178">θ</span><span class="MJXp-mo" id="MJXp-Span-179" style="margin-left: 0.333em; margin-right: 0.333em;">∣</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-180">x</span><span class="MJXp-mo" id="MJXp-Span-181" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-34">p(\boldsymbol\theta \mid \boldsymbol x)</script></span> và tương đương với việc cực đại hóa <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-182"><span class="MJXp-mi" id="MJXp-Span-183">log</span><span class="MJXp-mo" id="MJXp-Span-184" style="margin-left: 0em; margin-right: 0em;"></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-185">p</span><span class="MJXp-mo" id="MJXp-Span-186" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-187">x</span><span class="MJXp-mo" id="MJXp-Span-188" style="margin-left: 0.333em; margin-right: 0.333em;">∣</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-189">θ</span><span class="MJXp-mo" id="MJXp-Span-190" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-191" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mi" id="MJXp-Span-192">log</span><span class="MJXp-mo" id="MJXp-Span-193" style="margin-left: 0em; margin-right: 0em;"></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-194">p</span><span class="MJXp-mo" id="MJXp-Span-195" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-196">θ</span><span class="MJXp-mo" id="MJXp-Span-197" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-35">\log p(\boldsymbol x \mid \boldsymbol\theta) + \log p(\boldsymbol\theta)</script></span>. Số hạng <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-198"><span class="MJXp-mi" id="MJXp-Span-199">log</span><span class="MJXp-mo" id="MJXp-Span-200" style="margin-left: 0em; margin-right: 0em;"></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-201">p</span><span class="MJXp-mo" id="MJXp-Span-202" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-203">x</span><span class="MJXp-mo" id="MJXp-Span-204" style="margin-left: 0.333em; margin-right: 0.333em;">∣</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-205">θ</span><span class="MJXp-mo" id="MJXp-Span-206" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-36">\log p(\boldsymbol x \mid \boldsymbol\theta)</script></span> là logarit hàm hợp lý thường gặp của dữ liệu, và số hạng <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-207"><span class="MJXp-mi" id="MJXp-Span-208">log</span><span class="MJXp-mo" id="MJXp-Span-209" style="margin-left: 0em; margin-right: 0em;"></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-210">p</span><span class="MJXp-mo" id="MJXp-Span-211" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-212">θ</span><span class="MJXp-mo" id="MJXp-Span-213" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-37">\log p(\boldsymbol\theta)</script></span> - logarit hàm tiên nghiệm của tham số - là sự kết hợp các ưu tiên đối với các giá trị cụ thể của <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-214"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-215">θ</span></span></span><script type="math/tex" id="MathJax-Element-38">\boldsymbol\theta</script></span>. Quan điểm này đã được mô tả ở phần 5.6. Các bộ tự mã hóa có kiểm soát không tuân theo cách giải thích này bởi vì bộ kiểm soát phụ thuộc vào dữ liệu và do đó, nó không thể được định nghĩa như một tiên nghiệm theo đúng nghĩa của từ này. Tuy nhiên, ta vẫn có thể coi các số hạng kiểm soát này như là biểu thị sự ưu tiên các hàm số một cách ngầm định.</p><p>Thay vì coi mức phạt thưa như một cơ chế kiểm soát cho tác vụ sao chép, chúng ta có thể coi bộ tự mã hóa thưa như một quá trình huấn luyện cực đại hóa hàm hợp lý của một mô hình sinh mẫu có biến tiềm ẩn. Giả sử chúng ta có một mô hình với biến khả kiến <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-216"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-217">x</span></span></span><script type="math/tex" id="MathJax-Element-39">\boldsymbol x</script></span> và biến tiềm ẩn <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-218"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-219">h</span></span></span><script type="math/tex" id="MathJax-Element-40">\boldsymbol h</script></span>, với một phân phối đồng thời tường minh <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-220"><span class="MJXp-msubsup" id="MJXp-Span-221"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-222" style="margin-right: 0.05em;">p</span><span class="MJXp-mtext MJXp-script" id="MJXp-Span-223" style="vertical-align: -0.4em;">model</span></span><span class="MJXp-mo" id="MJXp-Span-224" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-225">x</span><span class="MJXp-mo" id="MJXp-Span-226" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-227">h</span><span class="MJXp-mo" id="MJXp-Span-228" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-229" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-msubsup" id="MJXp-Span-230"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-231" style="margin-right: 0.05em;">p</span><span class="MJXp-mtext MJXp-script" id="MJXp-Span-232" style="vertical-align: -0.4em;">model</span></span><span class="MJXp-mo" id="MJXp-Span-233" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-234">h</span><span class="MJXp-mo" id="MJXp-Span-235" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-msubsup" id="MJXp-Span-236"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-237" style="margin-right: 0.05em;">p</span><span class="MJXp-mtext MJXp-script" id="MJXp-Span-238" style="vertical-align: -0.4em;">model</span></span><span class="MJXp-mo" id="MJXp-Span-239" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-240">x</span><span class="MJXp-mo" id="MJXp-Span-241" style="margin-left: 0.333em; margin-right: 0.333em;">∣</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-242">h</span><span class="MJXp-mo" id="MJXp-Span-243" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-41">p_\text{model}(\boldsymbol x, \boldsymbol h) = p_\text{model}(\boldsymbol h) p_\text{model}(\boldsymbol x \mid \boldsymbol h)</script></span>. Coi <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-244"><span class="MJXp-msubsup" id="MJXp-Span-245"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-246" style="margin-right: 0.05em;">p</span><span class="MJXp-mtext MJXp-script" id="MJXp-Span-247" style="vertical-align: -0.4em;">model</span></span><span class="MJXp-mo" id="MJXp-Span-248" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-249">h</span><span class="MJXp-mo" id="MJXp-Span-250" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-42">p_\text{model}(\boldsymbol h)</script></span> là phân phối tiên nghiệm biểu diễn niềm tin của mô hình đối với các biến tiềm ẩn trước khi quan sát <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-251"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-252">x</span></span></span><script type="math/tex" id="MathJax-Element-43">\boldsymbol x</script></span>. Điều này khác với cách ta dùng từ “tiên nghiệm” trước đây để chỉ phân phối <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-253"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-254">p</span><span class="MJXp-mo" id="MJXp-Span-255" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-256">θ</span><span class="MJXp-mo" id="MJXp-Span-257" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-44">p(\boldsymbol\theta)</script></span> giúp mã hóa các niềm tin của chúng ta về tham số mô hình trước khi quan sát dữ liệu huấn luyện. Logarit của hàm hợp lý có thể được phân tách như sau:</p><p><span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-258"><span class="MJXp-mtable" id="MJXp-Span-259"><span><span class="MJXp-mlabeledtr" id="MJXp-Span-260" style="vertical-align: baseline;"><span class="MJXp-mtd" id="MJXp-Span-261" style="text-align: right;"><span class="MJXp-mi" id="MJXp-Span-262">log</span><span class="MJXp-mo" id="MJXp-Span-263" style="margin-left: 0em; margin-right: 0em;"></span><span class="MJXp-msubsup" id="MJXp-Span-264"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-265" style="margin-right: 0.05em;">p</span><span class="MJXp-mtext MJXp-script" id="MJXp-Span-266" style="vertical-align: -0.4em;">model</span></span><span class="MJXp-mo" id="MJXp-Span-267" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-268">x</span><span class="MJXp-mo" id="MJXp-Span-269" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-270" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi" id="MJXp-Span-271">log</span><span class="MJXp-mo" id="MJXp-Span-272" style="margin-left: 0em; margin-right: 0em;"></span><span class="MJXp-munderover" id="MJXp-Span-273"><span><span class="MJXp-mo" id="MJXp-Span-274" style="margin-left: 0.111em; margin-right: 0.167em;"><span class="MJXp-largeop">∑</span></span></span><span class="MJXp-script"><span class="MJXp-mrow" id="MJXp-Span-275" style="margin-left: 0px;"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-276">h</span></span></span></span><span class="MJXp-msubsup" id="MJXp-Span-277"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-278" style="margin-right: 0.05em;">p</span><span class="MJXp-mtext MJXp-script" id="MJXp-Span-279" style="vertical-align: -0.4em;">model</span></span><span class="MJXp-mo" id="MJXp-Span-280" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-281">h</span><span class="MJXp-mo" id="MJXp-Span-282" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-283">x</span><span class="MJXp-mo" id="MJXp-Span-284" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-285" style="margin-left: 0em; margin-right: 0.222em;">.</span></span></span></span></span></span></span><script type="math/tex; mode=display" id="MathJax-Element-45">\begin{align}
\log p_\text{model}(x) = \log \sum_{\boldsymbol h} p_\text{model}(\boldsymbol h, \boldsymbol x).
\tag{14.3}
\end{align}</script></span></p><p>Ta có thể coi bộ tự mã hóa như một quá trình xấp xỉ tổng trên với một ước lượng điểm cho một giá trị <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-286"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-287">h</span></span></span><script type="math/tex" id="MathJax-Element-46">\boldsymbol h</script></span> có khả năng cao xảy ra. Điều này tương tự như trong <em>mô hình mã hóa sinh mẫu thưa</em> (sparse coding generative model) được mô tả ở phần 13.4, nhưng <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-288"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-289">h</span></span></span><script type="math/tex" id="MathJax-Element-47">\boldsymbol h</script></span> là đầu ra của bộ mã hóa có tham số, thay vì là kết quả của một quá trình tối ưu hóa giúp suy luận ra giá trị <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-290"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-291">h</span></span></span><script type="math/tex" id="MathJax-Element-48">\boldsymbol h</script></span> có khả năng xảy ra cao nhất. Từ góc nhìn này, với <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-292"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-293">h</span></span></span><script type="math/tex" id="MathJax-Element-49">\boldsymbol h</script></span> được chọn như trên, chúng ta đang cực đại hóa giá trị của hàm<br>
<span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-294"><span class="MJXp-mtable" id="MJXp-Span-295"><span><span class="MJXp-mlabeledtr" id="MJXp-Span-296" style="vertical-align: baseline;"><span class="MJXp-mtd" id="MJXp-Span-297" style="text-align: right;"><span class="MJXp-mi" id="MJXp-Span-298">log</span><span class="MJXp-mo" id="MJXp-Span-299" style="margin-left: 0em; margin-right: 0em;"></span><span class="MJXp-msubsup" id="MJXp-Span-300"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-301" style="margin-right: 0.05em;">p</span><span class="MJXp-mtext MJXp-script" id="MJXp-Span-302" style="vertical-align: -0.4em;">model</span></span><span class="MJXp-mo" id="MJXp-Span-303" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-304">h</span><span class="MJXp-mo" id="MJXp-Span-305" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-306">x</span><span class="MJXp-mo" id="MJXp-Span-307" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-308" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi" id="MJXp-Span-309">log</span><span class="MJXp-mo" id="MJXp-Span-310" style="margin-left: 0em; margin-right: 0em;"></span><span class="MJXp-msubsup" id="MJXp-Span-311"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-312" style="margin-right: 0.05em;">p</span><span class="MJXp-mtext MJXp-script" id="MJXp-Span-313" style="vertical-align: -0.4em;">model</span></span><span class="MJXp-mo" id="MJXp-Span-314" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-315">h</span><span class="MJXp-mo" id="MJXp-Span-316" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-317" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mi" id="MJXp-Span-318">log</span><span class="MJXp-mo" id="MJXp-Span-319" style="margin-left: 0em; margin-right: 0em;"></span><span class="MJXp-msubsup" id="MJXp-Span-320"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-321" style="margin-right: 0.05em;">p</span><span class="MJXp-mtext MJXp-script" id="MJXp-Span-322" style="vertical-align: -0.4em;">model</span></span><span class="MJXp-mo" id="MJXp-Span-323" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-324">x</span><span class="MJXp-mo" id="MJXp-Span-325" style="margin-left: 0.333em; margin-right: 0.333em;">∣</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-326">h</span><span class="MJXp-mo" id="MJXp-Span-327" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-328" style="margin-left: 0em; margin-right: 0.222em;">.</span></span></span></span></span></span></span><script type="math/tex; mode=display" id="MathJax-Element-50">\begin{align}
\log p_\text{model}(\boldsymbol h, \boldsymbol x) = \log p_\text{model}(\boldsymbol h) + \log p_\text{model}(\boldsymbol x \mid 
\boldsymbol h).
\tag{14.4}
\end{align}</script></span></p><p>Với số hạng <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-329"><span class="MJXp-mi" id="MJXp-Span-330">log</span><span class="MJXp-mo" id="MJXp-Span-331" style="margin-left: 0em; margin-right: 0em;"></span><span class="MJXp-msubsup" id="MJXp-Span-332"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-333" style="margin-right: 0.05em;">p</span><span class="MJXp-mtext MJXp-script" id="MJXp-Span-334" style="vertical-align: -0.4em;">model</span></span><span class="MJXp-mo" id="MJXp-Span-335" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-336">h</span><span class="MJXp-mo" id="MJXp-Span-337" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-51">\log p_\text{model} (\boldsymbol h)</script></span> có thể là nguyên nhân gây ra tính thưa (sparsity inducing). Chẳng hạn, tiên nghiệm Lapalce,</p><p><span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-338"><span class="MJXp-mtable" id="MJXp-Span-339"><span><span class="MJXp-mlabeledtr" id="MJXp-Span-340" style="vertical-align: baseline;"><span class="MJXp-mtd" id="MJXp-Span-341" style="text-align: right;"><span class="MJXp-msubsup" id="MJXp-Span-342"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-343" style="margin-right: 0.05em;">p</span><span class="MJXp-mtext MJXp-script" id="MJXp-Span-344" style="vertical-align: -0.4em;">&nbsp;model</span></span><span class="MJXp-mo" id="MJXp-Span-345" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-msubsup" id="MJXp-Span-346"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-347" style="margin-right: 0.05em;">h</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-348" style="vertical-align: -0.4em;">i</span></span><span class="MJXp-mo" id="MJXp-Span-349" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-350" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mfrac" id="MJXp-Span-351" style="vertical-align: 0.25em;"><span class="MJXp-box"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-352">λ</span></span><span class="MJXp-box" style="margin-top: -0.9em;"><span class="MJXp-denom"><span><span class="MJXp-rule" style="height: 1em; border-top: none; border-bottom: 1px solid; margin: 0.1em 0px;"></span></span><span><span class="MJXp-box"><span class="MJXp-mn" id="MJXp-Span-353">2</span></span></span></span></span></span><span class="MJXp-msubsup" id="MJXp-Span-354"><span class="MJXp-mi" id="MJXp-Span-355" style="margin-right: 0.05em;">exp</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-356" style="vertical-align: 0.5em;"><span class="MJXp-mo" id="MJXp-Span-357">−</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-358">λ</span><span class="MJXp-mrow" id="MJXp-Span-359"><span class="MJXp-mo" id="MJXp-Span-360" style="vertical-align: -0.244em;"><span class="MJXp-right MJXp-scale7" style="font-size: 1.978em; margin-left: -0.013em;">|</span></span><span class="MJXp-msubsup" id="MJXp-Span-361"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-362" style="margin-right: 0.05em;">h</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-363" style="vertical-align: -0.4em;">i</span></span><span class="MJXp-mo" id="MJXp-Span-364" style="vertical-align: -0.244em;"><span class="MJXp-right MJXp-scale7" style="font-size: 1.978em; margin-left: -0.013em;">|</span></span></span></span></span><span class="MJXp-mo" id="MJXp-Span-365" style="margin-left: 0em; margin-right: 0.222em;">,</span></span></span></span></span></span></span><script type="math/tex; mode=display" id="MathJax-Element-52">\begin{align}
p_\text{ model} ( h_i ) = \frac { \lambda } { 2 } \exp ^ { - \lambda \left| h_i \right| },
\tag{14.5}
\end{align}</script></span></p><p>tương ứng với một mức phạt thưa tuyệt đối. Biểu diễn logarit của tiên nghiệm như một mức phạt tuyệt đối, ta thu được</p><p><span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-366"><span class="MJXp-mtable" id="MJXp-Span-367"><span><span class="MJXp-mtr" id="MJXp-Span-368" style="vertical-align: baseline;"><span class="MJXp-mtd" id="MJXp-Span-369" style="text-align: right;"></span></span><span class="MJXp-mlabeledtr" id="MJXp-Span-370" style="vertical-align: baseline;"><span class="MJXp-mtd" id="MJXp-Span-371" style="padding-top: 0.3em; text-align: right;"><span class="MJXp-mi" id="MJXp-Span-372">Ω</span><span class="MJXp-mo" id="MJXp-Span-373" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-374">h</span><span class="MJXp-mo" id="MJXp-Span-375" style="margin-left: 0em; margin-right: 0em;">)</span></span><span class="MJXp-mtd" id="MJXp-Span-376" style="padding-left: 0em; padding-top: 0.3em; text-align: center;"><span class="MJXp-mi" id="MJXp-Span-377"></span><span class="MJXp-mo" id="MJXp-Span-378" style="margin-left: 0.333em; margin-right: 0.333em;">=</span></span><span class="MJXp-mtd" id="MJXp-Span-379" style="padding-left: 0.278em; padding-top: 0.3em; text-align: left;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-380">λ</span><span class="MJXp-munderover" id="MJXp-Span-381"><span><span class="MJXp-mo" id="MJXp-Span-382" style="margin-left: 0.111em; margin-right: 0.167em;"><span class="MJXp-largeop">∑</span></span></span><span class="MJXp-script"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-383" style="margin-left: 0px;">i</span></span></span><span class="MJXp-mrow" id="MJXp-Span-384"><span class="MJXp-mo" id="MJXp-Span-385" style="margin-left: 0em; margin-right: 0em; vertical-align: -0.244em;"><span class="MJXp-right MJXp-scale7" style="font-size: 1.978em; margin-left: -0.013em;">|</span></span><span class="MJXp-msubsup" id="MJXp-Span-386"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-387" style="margin-right: 0.05em;">h</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-388" style="vertical-align: -0.4em;">i</span></span><span class="MJXp-mo" id="MJXp-Span-389" style="margin-left: 0em; margin-right: 0em; vertical-align: -0.244em;"><span class="MJXp-right MJXp-scale7" style="font-size: 1.978em; margin-left: -0.013em;">|</span></span></span><span class="MJXp-mo" id="MJXp-Span-390" style="margin-left: 0em; margin-right: 0.222em;">,</span></span></span><span class="MJXp-mlabeledtr" id="MJXp-Span-391" style="vertical-align: baseline;"><span class="MJXp-mtd" id="MJXp-Span-392" style="padding-top: 0.3em; text-align: right;"><span class="MJXp-mo" id="MJXp-Span-393" style="margin-left: 0em; margin-right: 0.111em;">−</span><span class="MJXp-mi" id="MJXp-Span-394">log</span><span class="MJXp-mo" id="MJXp-Span-395" style="margin-left: 0em; margin-right: 0em;"></span><span class="MJXp-msubsup" id="MJXp-Span-396"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-397" style="margin-right: 0.05em;">p</span><span class="MJXp-mtext MJXp-script" id="MJXp-Span-398" style="vertical-align: -0.4em;">model</span></span><span class="MJXp-mo" id="MJXp-Span-399" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-400">h</span><span class="MJXp-mo" id="MJXp-Span-401" style="margin-left: 0em; margin-right: 0em;">)</span></span><span class="MJXp-mtd" id="MJXp-Span-402" style="padding-left: 0em; padding-top: 0.3em; text-align: center;"><span class="MJXp-mi" id="MJXp-Span-403"></span><span class="MJXp-mo" id="MJXp-Span-404" style="margin-left: 0.333em; margin-right: 0.333em;">=</span></span><span class="MJXp-mtd" id="MJXp-Span-405" style="padding-left: 0.278em; padding-top: 0.3em; text-align: left;"><span class="MJXp-munderover" id="MJXp-Span-406"><span><span class="MJXp-mo" id="MJXp-Span-407" style="margin-left: 0.111em; margin-right: 0.167em;"><span class="MJXp-largeop">∑</span></span></span><span class="MJXp-script"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-408" style="margin-left: 0px;">i</span></span></span><span class="MJXp-mrow" id="MJXp-Span-409"><span class="MJXp-mo" id="MJXp-Span-410" style="margin-left: 0em; margin-right: 0em; vertical-align: -0.5em;"><span class="MJXp-right MJXp-scale5" style="font-size: 3em; margin-left: -0.13em;">(</span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-411">λ</span><span class="MJXp-mrow" id="MJXp-Span-412"><span class="MJXp-mo" id="MJXp-Span-413" style="margin-left: 0em; margin-right: 0em; vertical-align: -0.244em;"><span class="MJXp-right MJXp-scale7" style="font-size: 1.978em; margin-left: -0.013em;">|</span></span><span class="MJXp-msubsup" id="MJXp-Span-414"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-415" style="margin-right: 0.05em;">h</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-416" style="vertical-align: -0.4em;">i</span></span><span class="MJXp-mo" id="MJXp-Span-417" style="margin-left: 0em; margin-right: 0em; vertical-align: -0.244em;"><span class="MJXp-right MJXp-scale7" style="font-size: 1.978em; margin-left: -0.013em;">|</span></span></span><span class="MJXp-mo" id="MJXp-Span-418" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-mi" id="MJXp-Span-419">log</span><span class="MJXp-mo" id="MJXp-Span-420" style="margin-left: 0em; margin-right: 0em;"></span><span class="MJXp-mfrac" id="MJXp-Span-421" style="vertical-align: 0.25em;"><span class="MJXp-box"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-422">λ</span></span><span class="MJXp-box" style="margin-top: -0.9em;"><span class="MJXp-denom"><span><span class="MJXp-rule" style="height: 1em; border-top: none; border-bottom: 1px solid; margin: 0.1em 0px;"></span></span><span><span class="MJXp-box"><span class="MJXp-mn" id="MJXp-Span-423">2</span></span></span></span></span></span><span class="MJXp-mo" id="MJXp-Span-424" style="margin-left: 0em; margin-right: 0em; vertical-align: -0.5em;"><span class="MJXp-right MJXp-scale5" style="font-size: 3em; margin-left: -0.13em;">)</span></span></span><span class="MJXp-mo" id="MJXp-Span-425" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi" id="MJXp-Span-426">Ω</span><span class="MJXp-mo" id="MJXp-Span-427" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-428">h</span><span class="MJXp-mo" id="MJXp-Span-429" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-430" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mtext" id="MJXp-Span-431">const</span><span class="MJXp-mo" id="MJXp-Span-432" style="margin-left: 0em; margin-right: 0.222em;">,</span></span></span><span class="MJXp-mtr" id="MJXp-Span-433" style="vertical-align: baseline;"><span class="MJXp-mtd" id="MJXp-Span-434" style="padding-top: 0.3em; text-align: right;"></span></span></span></span></span></span><script type="math/tex; mode=display" id="MathJax-Element-53">\begin{eqnarray}\\
\Omega (\boldsymbol h) 
&=& \lambda \sum_i \left | h_i \right |,
\tag{14.6} \\
-\log p_\text{model}(\boldsymbol h) 
&=& \sum_i \left ( \lambda \left | h_i \right | - \log \frac{\lambda} {2} \right ) = \Omega (\boldsymbol h) + \text{const}, \tag{14.7} \\
\\\end{eqnarray}</script></span></p><p>trong đó giá trị hằng số chỉ phụ thuộc vào <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-435"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-436">λ</span></span></span><script type="math/tex" id="MathJax-Element-54">\lambda</script></span>, không phụ thuộc vào <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-437"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-438">h</span></span></span><script type="math/tex" id="MathJax-Element-55">\boldsymbol h</script></span>. Ta thường coi <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-439"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-440">λ</span></span></span><script type="math/tex" id="MathJax-Element-56">\lambda</script></span> là một siêu tham số và bỏ qua phần hằng số vì nó không ảnh hưởng gì đến quá trình học tham số. Những kiểu tiên nghiệm khác, chẳng hạn như tiên nghiệm Student <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-441"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-442">t</span></span></span><script type="math/tex" id="MathJax-Element-57">t</script></span> cũng có thể tạo ra tính thưa. Từ góc nhìn coi sự thưa thớt như là kết quả từ ảnh hưởng của <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-443"><span class="MJXp-msubsup" id="MJXp-Span-444"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-445" style="margin-right: 0.05em;">p</span><span class="MJXp-mtext MJXp-script" id="MJXp-Span-446" style="vertical-align: -0.4em;">model</span></span><span class="MJXp-mo" id="MJXp-Span-447" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-448">h</span><span class="MJXp-mo" id="MJXp-Span-449" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-58">p_\text{model}(\boldsymbol h)</script></span> lên quá trình học bằng việc cực đại hóa hàm hợp lý này, mức phạt thưa không còn là một số hạng kiểm soát nữa. Nó chỉ đơn giản là một hệ quả từ phân phối của mô hình đối với những biến tiềm ẩn của nó. Góc nhìn này cung cấp một động lực thúc đẩy khác cho nhiệm vụ huấn luyện một bộ tự mã hóa: nó là một phương pháp huấn luyện xấp xỉ cho một mô hình sinh mẫu. Nó đồng thời cũng cung cấp một giải thích khác cho câu hỏi vì sao những đặc trưng được học bởi bộ tự mã hóa là hữu ích: chúng mô tả những biến tiềm ẩn giúp giải thích đầu vào.</p><p>Những công trình đầu tiên về bộ tự mã hóa thưa [Ranzato <em>et al</em>, 2007a, 2008] đã khám phá ra rất nhiều dạng của tính thưa và đưa ra một mối liên hệ giữa mức phạt thưa và số hạng <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-450"><span class="MJXp-mi" id="MJXp-Span-451">log</span><span class="MJXp-mo" id="MJXp-Span-452" style="margin-left: 0em; margin-right: 0em;"></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-453">Z</span></span></span><script type="math/tex" id="MathJax-Element-59">\log Z</script></span> xuất hiện khi ta cực đại hóa hàm hợp lý trong một mô hình xác suất vô hướng <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-454"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-455">p</span><span class="MJXp-mo" id="MJXp-Span-456" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-457">x</span><span class="MJXp-mo" id="MJXp-Span-458" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-459" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mfrac" id="MJXp-Span-460" style="vertical-align: 0.25em;"><span class="MJXp-box MJXp-script"><span class="MJXp-mn" id="MJXp-Span-461">1</span></span><span class="MJXp-box" style="margin-top: -0.9em;"><span class="MJXp-denom"><span><span class="MJXp-rule" style="height: 1em; border-top: none; border-bottom: 1px solid; margin: 0.1em 0px;"></span></span><span><span class="MJXp-box MJXp-script"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-462">Z</span></span></span></span></span></span><span class="MJXp-mrow" id="MJXp-Span-463"><span class="MJXp-munderover" id="MJXp-Span-464"><span><span class="MJXp-over"><span style="margin-bottom: -1.17em;"><span class="MJXp-mo" id="MJXp-Span-466" style="margin-left: 0px; margin-right: 0px;">˜</span></span><span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-465">p</span></span></span></span></span></span><span class="MJXp-mo" id="MJXp-Span-467" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-468">x</span><span class="MJXp-mo" id="MJXp-Span-469" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-60">p ( \boldsymbol { x } ) = \frac { 1 } { Z } \tilde { p } ( \boldsymbol { x } )</script></span>. Ý tưởng cực tiểu hóa <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-470"><span class="MJXp-mi" id="MJXp-Span-471">log</span><span class="MJXp-mo" id="MJXp-Span-472" style="margin-left: 0em; margin-right: 0em;"></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-473">Z</span></span></span><script type="math/tex" id="MathJax-Element-61">\log Z</script></span> có thể giúp ta tránh tạo ra một mô hình xác suất có xác suất cao ở mọi nơi, và việc áp đặt tính thưa trên bộ tự mã hóa giúp bộ tự mã hóa này tránh được việc có sai số tái thiết thấp ở mọi đầu vào. Trong trường hợp này, mối liên hệ nằm ở cấp độ là một hiểu biết trực quan về cơ chế hoạt động chung hơn là sự tương đương về mặt toán học. Cách diễn giải rằng mức phạt thưa tương ứng với số hạng <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-474"><span class="MJXp-mi" id="MJXp-Span-475">log</span><span class="MJXp-mo" id="MJXp-Span-476" style="margin-left: 0em; margin-right: 0em;"></span><span class="MJXp-msubsup" id="MJXp-Span-477"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-478" style="margin-right: 0.05em;">p</span><span class="MJXp-mtext MJXp-script" id="MJXp-Span-479" style="vertical-align: -0.4em;">model</span></span><span class="MJXp-mo" id="MJXp-Span-480" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-481">h</span><span class="MJXp-mo" id="MJXp-Span-482" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-62">\log p_\text{model} (\boldsymbol h)</script></span> trong một một mô hình có hướng <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-483"><span class="MJXp-msubsup" id="MJXp-Span-484"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-485" style="margin-right: 0.05em;">p</span><span class="MJXp-mtext MJXp-script" id="MJXp-Span-486" style="vertical-align: -0.4em;">model</span></span><span class="MJXp-mo" id="MJXp-Span-487" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-488">h</span><span class="MJXp-mo" id="MJXp-Span-489" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-msubsup" id="MJXp-Span-490"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-491" style="margin-right: 0.05em;">p</span><span class="MJXp-mtext MJXp-script" id="MJXp-Span-492" style="vertical-align: -0.4em;">model</span></span><span class="MJXp-mo" id="MJXp-Span-493" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-494">x</span><span class="MJXp-mo" id="MJXp-Span-495" style="margin-left: 0.333em; margin-right: 0.333em;">∣</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-496">h</span><span class="MJXp-mo" id="MJXp-Span-497" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-63">p_\text{model} (\boldsymbol h) p_\text{model}(\boldsymbol x \mid \boldsymbol h)</script></span> sẽ tường minh hơn về mặt toán học.</p><p>Một cách để đạt được những giá trị <em><span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-498"><span class="MJXp-mn" id="MJXp-Span-499">0</span></span></span><script type="math/tex" id="MathJax-Element-64">0</script></span> thực sự</em> (actual zeros) trong <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-500"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-501">h</span></span></span><script type="math/tex" id="MathJax-Element-65">\boldsymbol h</script></span> để đạt được tính thưa (và giảm nhiễu) đã được giới thiệu trong công trình của Glorot và cộng sự (2011b). Ý tưởng của họ là sử dụng những bộ chỉnh lưu tuyến tính (ReLU) để tạo ra <em>tầng mã</em> (code layer). Với một tiên nghiệm thực sự đẩy các biểu diễn về giá trị <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-502"><span class="MJXp-mn" id="MJXp-Span-503">0</span></span></span><script type="math/tex" id="MathJax-Element-66">0</script></span> (như mức phạt tuyệt đối được mô tả ở trên), mô hình tự mã hóa này có thể gián tiếp điều khiển được trung bình số lượng các giá trị <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-504"><span class="MJXp-mn" id="MJXp-Span-505">0</span></span></span><script type="math/tex" id="MathJax-Element-67">0</script></span> xuất hiện trong việc biểu diễn.</p><p>------------------------<br>
Lại Minh Duy bắt đầu dịch từ đây<br>
------------------------</p><p>Trang 504 - 508</p><h2 id="1422-Bộ-tự-mã-hóa-khử-nhiễu-Denoising-Autoencoders"><a class="anchor hidden-xs" href="#1422-Bộ-tự-mã-hóa-khử-nhiễu-Denoising-Autoencoders" title="1422-Bộ-tự-mã-hóa-khử-nhiễu-Denoising-Autoencoders"><span class="octicon octicon-link"></span></a>14.2.2 Bộ tự mã hóa khử nhiễu (Denoising Autoencoders)</h2><p>Thay vì thêm một mức phạt <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-506"><span class="MJXp-mi" id="MJXp-Span-507">Ω</span></span></span><script type="math/tex" id="MathJax-Element-68">\Omega</script></span> vào hàm chi phí, chúng ta có thể thu được một bộ tự mã hóa có thể học những thông tin hữu ích bằng cách thay đổi số hạng sai số tái thiết trong hàm chi phí.</p><p>Như thường lệ, bộ tự mã hóa cực tiểu hóa hàm</p><p><span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-508"><span class="MJXp-mtable" id="MJXp-Span-509"><span><span class="MJXp-mlabeledtr" id="MJXp-Span-510" style="vertical-align: baseline;"><span class="MJXp-mtd" id="MJXp-Span-511" style="text-align: center;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-512">L</span><span class="MJXp-mo" id="MJXp-Span-513" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-514">x</span><span class="MJXp-mo" id="MJXp-Span-515" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mrow" id="MJXp-Span-516"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-517">g</span></span><span class="MJXp-mo" id="MJXp-Span-518" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mrow" id="MJXp-Span-519"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-520">f</span></span><span class="MJXp-mo" id="MJXp-Span-521" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-522">x</span><span class="MJXp-mo" id="MJXp-Span-523" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-524" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-525" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-526" style="margin-left: 0em; margin-right: 0.222em;">,</span></span></span></span></span></span></span><script type="math/tex; mode=display" id="MathJax-Element-69"> L(\boldsymbol x, \mathcal{g} (\mathcal{f} (\boldsymbol x))), \tag{14.8} </script></span></p><p>trong đó <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-527"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-528">L</span></span></span><script type="math/tex" id="MathJax-Element-70">L</script></span> là hàm mất mát, phạt <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-529"><span class="MJXp-mrow" id="MJXp-Span-530"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-531">g</span></span><span class="MJXp-mo" id="MJXp-Span-532" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mrow" id="MJXp-Span-533"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-534">f</span></span><span class="MJXp-mo" id="MJXp-Span-535" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-536">x</span><span class="MJXp-mo" id="MJXp-Span-537" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-538" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-71">\mathcal{g}(\mathcal{f} (\boldsymbol x))</script></span> khi không giống với <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-539"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-540">x</span></span></span><script type="math/tex" id="MathJax-Element-72">\boldsymbol x</script></span>, chẳng hạn như là chuẩn <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-541"><span class="MJXp-msubsup" id="MJXp-Span-542"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-543" style="margin-right: 0.05em;">L</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-544" style="vertical-align: 0.5em;">2</span></span></span></span><script type="math/tex" id="MathJax-Element-73">L^2</script></span> trên khác nhau của chúng. Điều này vô tình khuyến khích <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-545"><span class="MJXp-mrow" id="MJXp-Span-546"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-547">g</span></span><span class="MJXp-mo" id="MJXp-Span-548" style="margin-left: 0.267em; margin-right: 0.267em;">∘</span><span class="MJXp-mrow" id="MJXp-Span-549"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-550">f</span></span></span></span><script type="math/tex" id="MathJax-Element-74">\mathcal{g} \circ \mathcal{f}</script></span> học chỉ để trở thành một hàm đồng nhất nếu chúng có đủ dung lượng.</p><p>Một <em>bộ tự mã hóa khử nhiễu</em> (Denoising Autoencoder -  DAE) thay vào đó sẽ cực tiểu hóa hàm</p><p><span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-551"><span class="MJXp-mtable" id="MJXp-Span-552"><span><span class="MJXp-mlabeledtr" id="MJXp-Span-553" style="vertical-align: baseline;"><span class="MJXp-mtd" id="MJXp-Span-554" style="text-align: center;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-555">L</span><span class="MJXp-mo" id="MJXp-Span-556" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-557">x</span><span class="MJXp-mo" id="MJXp-Span-558" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mrow" id="MJXp-Span-559"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-560">g</span></span><span class="MJXp-mo" id="MJXp-Span-561" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mrow" id="MJXp-Span-562"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-563">f</span></span><span class="MJXp-mo" id="MJXp-Span-564" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mrow" id="MJXp-Span-565"><span class="MJXp-munderover" id="MJXp-Span-566"><span><span class="MJXp-over"><span style="margin-bottom: -1.17em;"><span class="MJXp-mo" id="MJXp-Span-568" style="margin-left: 0px; margin-right: 0px;">˜</span></span><span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-567">x</span></span></span></span></span></span><span class="MJXp-mo" id="MJXp-Span-569" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-570" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-571" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-572" style="margin-left: 0em; margin-right: 0.222em;">,</span></span></span></span></span></span></span><script type="math/tex; mode=display" id="MathJax-Element-75">L(\boldsymbol x, \mathcal{g}(\mathcal{f}(\widetilde{\boldsymbol x}))), \tag{14.9} </script></span></p><p>trong đó <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-573"><span class="MJXp-mrow" id="MJXp-Span-574"><span class="MJXp-munderover" id="MJXp-Span-575"><span><span class="MJXp-over"><span style="margin-bottom: -1.17em;"><span class="MJXp-mo" id="MJXp-Span-577" style="margin-left: 0px; margin-right: 0px;">˜</span></span><span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-576">x</span></span></span></span></span></span></span></span><script type="math/tex" id="MathJax-Element-76">\widetilde{\boldsymbol x}</script></span> là một bản sao bị trộn lẫn một vài dạng nhiễu của <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-578"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-579">x</span></span></span><script type="math/tex" id="MathJax-Element-77">\boldsymbol x</script></span>. Bộ mã tự hóa khi đó buộc phải làm thêm một nhiệm vụ là khử những nhiễu này thay vì chỉ sao chép đầu vào của chúng.</p><p>Quá trình huấn luyện khử nhiễu này buộc <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-580"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-581">f</span></span></span><script type="math/tex" id="MathJax-Element-78">f</script></span> và <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-582"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-583">g</span></span></span><script type="math/tex" id="MathJax-Element-79">g</script></span> ngầm học cấu trúc của <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-584"><span class="MJXp-msubsup" id="MJXp-Span-585"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-586" style="margin-right: 0.05em;">p</span><span class="MJXp-mtext MJXp-script" id="MJXp-Span-587" style="vertical-align: -0.4em;">data</span></span><span class="MJXp-mo" id="MJXp-Span-588" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-589">x</span><span class="MJXp-mo" id="MJXp-Span-590" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-80">p_\text{data}(\boldsymbol x)</script></span>, như được trình bày bởi Alain và Bengio (2013), Bengio cùng cộng sự (2013c). Do đó, các bộ tự mã hóa khử nhiễu là một ví dụ khác về cách trích xuất các thuộc tính hữu ích như một tác dụng phụ của quá trình cực tiểu hóa sai số tái thiết. Chúng cũng là một ví dụ về cách sử dụng các mô hình vượt mức và có dung lượng cao như một bộ tự mã hóa, miễn là chúng bị ngăn cản khỏi việc học hàm đồng nhất. Chi tiết về bộ tự mã hóa khử nhiễu sẽ được trình bày trong phần 14.5</p><p>--------- Phát đã edit tới đây</p><h1 id="1423-Kiểm-soát-bằng-phạt-đạo-hàm"><a class="anchor hidden-xs" href="#1423-Kiểm-soát-bằng-phạt-đạo-hàm" title="1423-Kiểm-soát-bằng-phạt-đạo-hàm"><span class="octicon octicon-link"></span></a>14.2.3 Kiểm soát bằng phạt đạo hàm.</h1><p>Một chiến lược khác để kiểm soát bộ tự mã hóa là sử dụng một mức phạt <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-591"><span class="MJXp-mi" id="MJXp-Span-592">Ω</span></span></span><script type="math/tex" id="MathJax-Element-81">\Omega</script></span>, như trong bộ tự mã hóa thưa,</p><p><span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-593"><span class="MJXp-mtable" id="MJXp-Span-594"><span><span class="MJXp-mlabeledtr" id="MJXp-Span-595" style="vertical-align: baseline;"><span class="MJXp-mtd" id="MJXp-Span-596" style="text-align: center;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-597">L</span><span class="MJXp-mo" id="MJXp-Span-598" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-599">x</span><span class="MJXp-mo" id="MJXp-Span-600" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mrow" id="MJXp-Span-601"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-602">g</span></span><span class="MJXp-mo" id="MJXp-Span-603" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mrow" id="MJXp-Span-604"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-605">f</span></span><span class="MJXp-mo" id="MJXp-Span-606" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-607">x</span><span class="MJXp-mo" id="MJXp-Span-608" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-609" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-610" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-611" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mi" id="MJXp-Span-612">Ω</span><span class="MJXp-mo" id="MJXp-Span-613" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-614">h</span><span class="MJXp-mo" id="MJXp-Span-615" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-616">x</span><span class="MJXp-mo" id="MJXp-Span-617" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-618" style="margin-left: 0em; margin-right: 0.222em;">,</span></span></span></span></span></span></span><script type="math/tex; mode=display" id="MathJax-Element-82"> L(\boldsymbol x, \mathcal{g}(\mathcal{f}(\boldsymbol x))) + \Omega(\boldsymbol h, \boldsymbol x), 
\tag{14.10} </script></span></p><p>nhưng với một dạng <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-619"><span class="MJXp-mi" id="MJXp-Span-620">Ω</span></span></span><script type="math/tex" id="MathJax-Element-83">\Omega</script></span> khác:<br>
<span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-638"><span class="MJXp-mtable" id="MJXp-Span-639"><span><span class="MJXp-mlabeledtr" id="MJXp-Span-640" style="vertical-align: baseline;"><span class="MJXp-mtd" id="MJXp-Span-641" style="text-align: center;"><span class="MJXp-mi" id="MJXp-Span-642">Ω</span><span class="MJXp-mo" id="MJXp-Span-643" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-644">h</span><span class="MJXp-mo" id="MJXp-Span-645" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-646">x</span><span class="MJXp-mo" id="MJXp-Span-647" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-648" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-649">λ</span><span class="MJXp-munderover" id="MJXp-Span-650"><span><span class="MJXp-mo" id="MJXp-Span-651" style="margin-left: 0.111em; margin-right: 0.167em;"><span class="MJXp-largeop">∑</span></span></span><span class="MJXp-script"><span class="MJXp-mrow" id="MJXp-Span-652" style="margin-left: 0px;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-653">i</span></span></span></span><span class="MJXp-mo" id="MJXp-Span-654" style="margin-left: 0em; margin-right: 0em;">‖</span><span class="MJXp-msubsup" id="MJXp-Span-655"><span class="MJXp-mi" id="MJXp-Span-656" style="margin-right: 0.05em;">∇</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-657" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-658">x</span></span></span><span class="MJXp-msubsup" id="MJXp-Span-659"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-660" style="margin-right: 0.05em;">h</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-661" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-662">i</span></span></span><span class="MJXp-msubsup" id="MJXp-Span-663"><span class="MJXp-mo" id="MJXp-Span-664" style="margin-left: 0em; margin-right: 0.05em;">‖</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-665" style="vertical-align: 0.5em;">2</span></span><span class="MJXp-mo" id="MJXp-Span-666" style="margin-left: 0em; margin-right: 0.222em;">.</span></span></span></span></span></span></span><script type="math/tex; mode=display" id="MathJax-Element-84"> \Omega(\boldsymbol h, \boldsymbol x) = \lambda \sum_{i} \| \nabla_{\boldsymbol x}h_{i} \|^2. 
\tag{14.11} </script></span></p><p>Điều này buộc mô hình học một hàm không thay đổi quá nhiều khi <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-667"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-668">x</span></span></span><script type="math/tex" id="MathJax-Element-85">x</script></span> thay đổi một lượng nhỏ. Bởi vì mức phạt này chỉ được áp dụng trong các mẫu huấn luyện, nó buộc bộ tự mã hóa tự động học tập đặc trưng giúp nắm bắt thông tin về phân phối huấn luyện.</p><p>Bộ tự mã hóa có kiểm soát này được gọi là <strong>bộ tự mã hóa chèn ép</strong> (contractive autoencoder - CAE). Cách tiếp cận này về lý thuyết có liên quan tới bộ tự mã hóa khử nhiễu, học đa tạp và mô hình hóa xác suất. CAE sẽ được mô tả chi tiết hơn trong phần 14.7.</p><h1 id="143-Bậc-của-biểu-diễn-kích-thước-của-tầng-và-tính-sâu"><a class="anchor hidden-xs" href="#143-Bậc-của-biểu-diễn-kích-thước-của-tầng-và-tính-sâu" title="143-Bậc-của-biểu-diễn-kích-thước-của-tầng-và-tính-sâu"><span class="octicon octicon-link"></span></a>14.3 Bậc của biểu diễn, kích thước của tầng và tính sâu.</h1><p>Các bộ tự mã hóa thường được huấn luyện chỉ với một tầng mã hóa và một tầng giải mã. Tuy nhiên, đây không phải một điều kiện tất yếu. Trên thực tế, sử dụng các bộ mã hóa và giải mã đa tầng sở hữu nhiều ưu điểm.</p><p>Phần 6.4.1 đã chỉ ra nhiều lợi thế các mạng lan truyền thuận đa tầng. Do bộ tự mã hóa, các thành phần của nó (bộ mã hóa và bộ giải mã) là mạng lan truyền thuận nên nó cũng thừa hưởng những ưu điểm này.</p><p>Một lợi thế chính của tính sâu đó là định lý mô hình xấp xỉ phổ quát đảm bảo rằng một mạng neuron lan truyền thuận với ít nhất một tầng ẩn là đủ để biểu diễn xấp xỉ của bất kỳ hàm nào (trong một lớp rộng) với độ chính xác tùy ý, miễn là nó có đủ số đơn vị ẩn cần thiết. Điều này có nghĩa là một bộ tự mã hóa với một tầng ẩn duy nhất có khả năng biểu diễn chính xác hàm đồng nhất dọc theo miền của dữ liệu bất kỳ. Tuy nhiên, phép ánh xạ từ đầu vào tới đoạn mã hóa là nông. Nghĩa là ta không thể thực thi các ràng buộc tùy ý, chẳng hạn như tính thưa của đoạn mã hóa. Một bộ tự mã hóa đa tầng, với ít nhất một tầng ẩn bổ sung bên trong bộ mã hóa, có thể xấp xỉ bất kỳ phép ánh xạ nào từ đầu vào tới đoạn mã hóa, miễn là nó có đủ các đơn vị ẩn.</p><p>Tính sâu của mạng có thể làm giảm chi phí tính toán để biểu diễn một số hàm theo cấp số nhân. Tính sâu của mạng cũng có thể làm giảm số lượng dữ liệu huấn luyện cần thiết để học một số hàm theo cấp số nhân. Xem phần 6.4.1 để tổng kết về các ưu điểm của tính sâu trong các mạng lan truyền thuận.</p><p>Qua thực nghiệm, các bộ tự mã hóa sâu có khả năng nén tốt hơn nhiều so với các bộ tự mã hóa nông tương ứng hoặc bộ tự mã hóa tuyến tính [Hinton and Salakhutdinov, 2006].</p><p>Một chiến lược phổ biến để huấn luyện một bộ tự mã hóa sâu đó là tiền huấn luyện tham lam một kiến trúc đa tầng bằng cách huấn luyện nhiều bộ tự mã hóa nông theo cấu trúc ngăn xếp, vì vậy chúng ta thường làm việc với các bộ tự mã hóa nông, ngay cả khi mục tiêu cuối cùng là huấn luyện bộ tự mã hóa đa tầng.</p><h1 id="144-Các-bộ-mã-hóa-và-giải-mã-ngẫu-nhiên"><a class="anchor hidden-xs" href="#144-Các-bộ-mã-hóa-và-giải-mã-ngẫu-nhiên" title="144-Các-bộ-mã-hóa-và-giải-mã-ngẫu-nhiên"><span class="octicon octicon-link"></span></a>14.4 Các bộ mã hóa và giải mã ngẫu nhiên</h1><p>Các bộ tự mã hóa chỉ là các mạng lan truyền thuận. Do đó, các hàm mất mát và các loại đơn vị đầu ra được sử dụng trong các mạng lan truyền thuận truyền thống cũng có thể được sử dụng trong các bộ tự mã hóa.</p><p>Như được mô tả trong phần 6.2.2.4, có một chiến lược chung để thiết kế các đơn vị đầu ra và hàm mất mát trong mạng lan truyền thuận, đó là xác định một phân phối đầu ra <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-669"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-670">p</span><span class="MJXp-mo" id="MJXp-Span-671" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-672">y</span><span class="MJXp-mo" id="MJXp-Span-673" style="margin-left: 0.333em; margin-right: 0.333em;">∣</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-674">x</span><span class="MJXp-mo" id="MJXp-Span-675" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-86">p(\boldsymbol y \mid \boldsymbol x)</script></span> và cực tiểu hóa số đối của logarit hàm hợp lý <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-676"><span class="MJXp-mo" id="MJXp-Span-677" style="margin-left: 0em; margin-right: 0.111em;">−</span><span class="MJXp-mi" id="MJXp-Span-678">log</span><span class="MJXp-mo" id="MJXp-Span-679" style="margin-left: 0em; margin-right: 0em;"></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-680">p</span><span class="MJXp-mo" id="MJXp-Span-681" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-682">y</span><span class="MJXp-mo" id="MJXp-Span-683" style="margin-left: 0.333em; margin-right: 0.333em;">∣</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-684">x</span><span class="MJXp-mo" id="MJXp-Span-685" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-87">- \log p (\boldsymbol y \mid \boldsymbol x)</script></span>. Trong thiết lập này, <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-686"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-687">y</span></span></span><script type="math/tex" id="MathJax-Element-88">\boldsymbol y</script></span> là một vector mục tiêu, chẳng hạn như các nhãn của lớp.</p><p>========== Phát đã edit tới đây</p><p>Trong một bộ tự mã hóa, <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-688"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-689">x</span></span></span><script type="math/tex" id="MathJax-Element-89">\boldsymbol x</script></span> vừa là đầu vào vừa là mục tiêu. Tuy nhiên, ta vẫn có thể áp dụng cùng một cơ chế như trên. Từ đoạn mã ẩn <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-690"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-691">h</span></span></span><script type="math/tex" id="MathJax-Element-90">\boldsymbol h</script></span>, bộ giải mã cung cấp phân phối có điều kiện <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-692"><span class="MJXp-msubsup" id="MJXp-Span-693"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-694" style="margin-right: 0.05em;">p</span><span class="MJXp-mtext MJXp-script" id="MJXp-Span-695" style="vertical-align: -0.4em;">decoder</span></span><span class="MJXp-mo" id="MJXp-Span-696" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-697">x</span><span class="MJXp-mo" id="MJXp-Span-698" style="margin-left: 0.333em; margin-right: 0.333em;">∣</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-699">h</span><span class="MJXp-mo" id="MJXp-Span-700" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-91">p_\text{decoder}(\boldsymbol x \mid \boldsymbol h)</script></span>. Ta có thể huấn luyện bộ tự mã hóa này bằng cách cực tiểu hóa  <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-701"><span class="MJXp-mo" id="MJXp-Span-702" style="margin-left: 0em; margin-right: 0.111em;">−</span><span class="MJXp-mi" id="MJXp-Span-703">log</span><span class="MJXp-mo" id="MJXp-Span-704" style="margin-left: 0em; margin-right: 0em;"></span><span class="MJXp-msubsup" id="MJXp-Span-705"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-706" style="margin-right: 0.05em;">p</span><span class="MJXp-mtext MJXp-script" id="MJXp-Span-707" style="vertical-align: -0.4em;">&nbsp;decoder&nbsp;</span></span><span class="MJXp-mo" id="MJXp-Span-708" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-709">x</span><span class="MJXp-mo" id="MJXp-Span-710" style="margin-left: 0.333em; margin-right: 0.333em;">∣</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-711">h</span><span class="MJXp-mo" id="MJXp-Span-712" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-92">-\log p_\text{ decoder } ( \boldsymbol { x } \mid \boldsymbol { h } )</script></span>. Dạng chính xác của hàm mất mát này sẽ thay đổi tùy theo dạng của <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-713"><span class="MJXp-msubsup" id="MJXp-Span-714"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-715" style="margin-right: 0.05em;">p</span><span class="MJXp-mtext MJXp-script" id="MJXp-Span-716" style="vertical-align: -0.4em;">decoder</span></span></span></span><script type="math/tex" id="MathJax-Element-93">p_\text{decoder}</script></span>. Tương tự như các mạng lan truyền thuận truyền thống, ta thường sử dụng các đơn vị đầu ra tuyến tính để tham số hóa giá trị trung bình của một phân phối Gauss nếu <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-717"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-718">x</span></span></span><script type="math/tex" id="MathJax-Element-94">\boldsymbol x</script></span> là số thực. Khi đó, số đối của logarit hàm hợp lý sẽ tạo ra một tiêu chuẩn theo trung bình bình phương sai số. Tương tự, <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-719"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-720">x</span></span></span><script type="math/tex" id="MathJax-Element-95">\boldsymbol x</script></span> sẽ tương ứng với một phân phối Bernoulli có tham số được cho bởi một đơn vị đầu ra sigmoid nếu các giá trị của nó là nhị phân, và các giá trị <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-721"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-722">x</span></span></span><script type="math/tex" id="MathJax-Element-96">\boldsymbol x</script></span> rời rạc sẽ tương ứng với phân phối softmax, v.v. Thông thường, các biến đầu ra sẽ được coi là độc lập có điều kiện với <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-723"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-724">h</span></span></span><script type="math/tex" id="MathJax-Element-97">\boldsymbol h</script></span> để giảm bớt chi phí tính toán phân phối xác suất của chúng, nhưng một số kỹ thuật cho phép điều chỉnh quá trình mô hình hóa đầu ra bằng sự tương quan, chẳng hạn như với các <em>đầu ra mật độ hỗn hợp</em> (mixture density output).</p><p>Để thực hiện một khởi đầu hiệu quả hơn với các mạng lan truyền thuận được đề cập trước đây, ta có thể khái quát hóa khái niệm <em>hàm mã hóa</em> (encoding function) <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-725"><span class="MJXp-mrow" id="MJXp-Span-726"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-727">f</span></span><span class="MJXp-mo" id="MJXp-Span-728" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-729">x</span><span class="MJXp-mo" id="MJXp-Span-730" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-98">\mathcal{f}(\boldsymbol x)</script></span> lên thành <em>phân phối mã hóa</em> (encoding distribution) <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-731"><span class="MJXp-msubsup" id="MJXp-Span-732"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-733" style="margin-right: 0.05em;">p</span><span class="MJXp-mtext MJXp-script" id="MJXp-Span-734" style="vertical-align: -0.4em;">encoder</span></span><span class="MJXp-mo" id="MJXp-Span-735" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-736">h</span><span class="MJXp-mo" id="MJXp-Span-737" style="margin-left: 0.333em; margin-right: 0.333em;">∣</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-738">x</span><span class="MJXp-mo" id="MJXp-Span-739" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-99">p_\text{encoder}(\boldsymbol h \mid \boldsymbol x)</script></span>, như minh họa trong hình 14.2.</p><p><img src="https://i.imgur.com/lXDoFCT.png" alt=""></p><blockquote>
<p>Hình 14.2: Cấu trúc của một bộ tự mã hóa ngẫu nhiên, trong đó bộ mã hóa và bộ giải mã không chỉ là các hàm đơn giản mà sẽ bao gồm một số nhiễu được thêm vào, nghĩa là đầu ra của chúng có thể được xem như các mẫu lấy từ phân phối <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-740"><span class="MJXp-msubsup" id="MJXp-Span-741"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-742" style="margin-right: 0.05em;">p</span><span class="MJXp-mtext MJXp-script" id="MJXp-Span-743" style="vertical-align: -0.4em;">encoder</span></span><span class="MJXp-mo" id="MJXp-Span-744" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-745">h</span><span class="MJXp-mo" id="MJXp-Span-746" style="margin-left: 0.333em; margin-right: 0.333em;">∣</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-747">x</span><span class="MJXp-mo" id="MJXp-Span-748" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-100">p_\text{encoder}(\boldsymbol h \mid \boldsymbol x)</script></span> cho bộ mã hóa và <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-749"><span class="MJXp-msubsup" id="MJXp-Span-750"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-751" style="margin-right: 0.05em;">p</span><span class="MJXp-mtext MJXp-script" id="MJXp-Span-752" style="vertical-align: -0.4em;">decoder</span></span><span class="MJXp-mo" id="MJXp-Span-753" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-754">x</span><span class="MJXp-mo" id="MJXp-Span-755" style="margin-left: 0.333em; margin-right: 0.333em;">∣</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-756">h</span><span class="MJXp-mo" id="MJXp-Span-757" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-101">p_\text{decoder}(\boldsymbol x \mid\boldsymbol h)</script></span> cho bộ giải mã.</p>
</blockquote><p>Bất kỳ mô hình biến tiềm ẩn <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-758"><span class="MJXp-msubsup" id="MJXp-Span-759"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-760" style="margin-right: 0.05em;">p</span><span class="MJXp-mtext MJXp-script" id="MJXp-Span-761" style="vertical-align: -0.4em;">mode</span></span><span class="MJXp-mo" id="MJXp-Span-762" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-763">h</span><span class="MJXp-mo" id="MJXp-Span-764" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-765">x</span><span class="MJXp-mo" id="MJXp-Span-766" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-102">p_\text{mode} (\boldsymbol h, \boldsymbol x)</script></span> nào đều có thể cấu thành một bộ mã hóa ngẫu nhiên</p><p><span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-767"><span class="MJXp-mtable" id="MJXp-Span-768"><span><span class="MJXp-mlabeledtr" id="MJXp-Span-769" style="vertical-align: baseline;"><span class="MJXp-mtd" id="MJXp-Span-770" style="text-align: center;"><span class="MJXp-msubsup" id="MJXp-Span-771"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-772" style="margin-right: 0.05em;">p</span><span class="MJXp-mtext MJXp-script" id="MJXp-Span-773" style="vertical-align: -0.4em;">encoder</span></span><span class="MJXp-mo" id="MJXp-Span-774" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-775">h</span><span class="MJXp-mo" id="MJXp-Span-776" style="margin-left: 0.333em; margin-right: 0.333em;">∣</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-777">x</span><span class="MJXp-mo" id="MJXp-Span-778" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-779" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-msubsup" id="MJXp-Span-780"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-781" style="margin-right: 0.05em;">p</span><span class="MJXp-mtext MJXp-script" id="MJXp-Span-782" style="vertical-align: -0.4em;">model</span></span><span class="MJXp-mo" id="MJXp-Span-783" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-784">h</span><span class="MJXp-mo" id="MJXp-Span-785" style="margin-left: 0.333em; margin-right: 0.333em;">∣</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-786">x</span><span class="MJXp-mo" id="MJXp-Span-787" style="margin-left: 0em; margin-right: 0em;">)</span></span></span></span></span></span></span><script type="math/tex; mode=display" id="MathJax-Element-103"> p_\text{encoder}(\boldsymbol h \mid\boldsymbol x) = p_\text{model}(\boldsymbol h \mid\boldsymbol x) \tag{14.12}
</script></span></p><p>và một bộ giải mã ngẫu nhiên</p><p><span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-788"><span class="MJXp-mtable" id="MJXp-Span-789"><span><span class="MJXp-mlabeledtr" id="MJXp-Span-790" style="vertical-align: baseline;"><span class="MJXp-mtd" id="MJXp-Span-791" style="text-align: center;"><span class="MJXp-msubsup" id="MJXp-Span-792"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-793" style="margin-right: 0.05em;">p</span><span class="MJXp-mtext MJXp-script" id="MJXp-Span-794" style="vertical-align: -0.4em;">decoder</span></span><span class="MJXp-mo" id="MJXp-Span-795" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-796">x</span><span class="MJXp-mo" id="MJXp-Span-797" style="margin-left: 0.333em; margin-right: 0.333em;">∣</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-798">h</span><span class="MJXp-mo" id="MJXp-Span-799" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-800" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-msubsup" id="MJXp-Span-801"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-802" style="margin-right: 0.05em;">p</span><span class="MJXp-mtext MJXp-script" id="MJXp-Span-803" style="vertical-align: -0.4em;">model</span></span><span class="MJXp-mo" id="MJXp-Span-804" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-805">x</span><span class="MJXp-mo" id="MJXp-Span-806" style="margin-left: 0.333em; margin-right: 0.333em;">∣</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-807">h</span><span class="MJXp-mo" id="MJXp-Span-808" style="margin-left: 0em; margin-right: 0em;">)</span></span></span></span></span></span></span><script type="math/tex; mode=display" id="MathJax-Element-104">p_\text{decoder}(\boldsymbol x \mid \boldsymbol h) = p_\text{model}(\boldsymbol x \mid\boldsymbol h) \tag{14.13}</script></span></p><p>Nhìn chung, các phân phối mã hóa và giải mã không nhất thiết phải là phân phối có điều kiện tương thích với một phân phối đồng thời duy nhất<br>
<span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-809"><span class="MJXp-msubsup" id="MJXp-Span-810"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-811" style="margin-right: 0.05em;">p</span><span class="MJXp-mtext MJXp-script" id="MJXp-Span-812" style="vertical-align: -0.4em;">model</span></span><span class="MJXp-mo" id="MJXp-Span-813" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-814">x</span><span class="MJXp-mo" id="MJXp-Span-815" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-816">h</span><span class="MJXp-mo" id="MJXp-Span-817" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-105">p_\text{model}(\boldsymbol x,\boldsymbol h)</script></span>. Alain cùng cộng sự (2015) đã chứng minh rằng việc huấn luyện bộ mã hóa và bộ giải mã như một bộ tự mã hóa khử nhiễu sẽ có xu hướng khiến chúng tiệm cận sự tương thích (nếu mô hình có đủ dung lượng và số lượng mẫu cần thiết).</p><h1 id="145-Bộ-tự-mã-hóa-khử-nhiễu"><a class="anchor hidden-xs" href="#145-Bộ-tự-mã-hóa-khử-nhiễu" title="145-Bộ-tự-mã-hóa-khử-nhiễu"><span class="octicon octicon-link"></span></a>14.5 Bộ tự mã hóa khử nhiễu</h1><p><em>Bộ tự tự mã hóa khử nhiễu</em> (denoising autoencoder - DAE) là bộ tự mã hóa có đầu vào là các điểm dữ liệu đã bị sửa đổi và được huấn luyện để dự đoán đầu ra là các điểm dữ liệu gốc, không bị sửa đổi.</p><p>Quá trình huấn luyện DAE được minh họa trong hình 14.3. Ta bắt đầu bằng một quy trình sửa đổi <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-818"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-819">C</span><span class="MJXp-mo" id="MJXp-Span-820" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mrow" id="MJXp-Span-821"><span class="MJXp-mrow" id="MJXp-Span-822"><span class="MJXp-munderover" id="MJXp-Span-823"><span><span class="MJXp-over"><span style="margin-bottom: -1.17em;"><span class="MJXp-mo MJXp-bold" id="MJXp-Span-825" style="margin-left: 0px; margin-right: 0px;">˜</span></span><span><span class="MJXp-mi MJXp-bold" id="MJXp-Span-824">x</span></span></span></span></span></span></span><span class="MJXp-mo" id="MJXp-Span-826" style="margin-left: 0.333em; margin-right: 0.333em;">∣</span><span class="MJXp-mrow" id="MJXp-Span-827"><span class="MJXp-mi MJXp-bold" id="MJXp-Span-828">x</span></span><span class="MJXp-mo" id="MJXp-Span-829" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-106">C(\mathbf{\widetilde x} \mid \mathbf{x})</script></span>, đại diện cho phân phối có điều kiện của các mẫu bị sửa đổi <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-830"><span class="MJXp-mrow" id="MJXp-Span-831"><span class="MJXp-mrow" id="MJXp-Span-832"><span class="MJXp-munderover" id="MJXp-Span-833"><span><span class="MJXp-over"><span style="margin-bottom: -1.17em;"><span class="MJXp-mo MJXp-bold" id="MJXp-Span-835" style="margin-left: 0px; margin-right: 0px;">˜</span></span><span><span class="MJXp-mi MJXp-bold" id="MJXp-Span-834">x</span></span></span></span></span></span></span></span></span><script type="math/tex" id="MathJax-Element-107">\mathbf{\widetilde x}</script></span>, với mẫu dữ liệu <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-836"><span class="MJXp-mrow" id="MJXp-Span-837"><span class="MJXp-mi MJXp-bold" id="MJXp-Span-838">x</span></span></span></span><script type="math/tex" id="MathJax-Element-108">\mathbf{x}</script></span> cho trước. Sau đó, bộ tự mã hóa sẽ học một <em>phân phối tái thiết</em> <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-839"><span class="MJXp-msubsup" id="MJXp-Span-840"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-841" style="margin-right: 0.05em;">p</span><span class="MJXp-mtext MJXp-script" id="MJXp-Span-842" style="vertical-align: -0.4em;">reconstruct</span></span><span class="MJXp-mo" id="MJXp-Span-843" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mrow" id="MJXp-Span-844"><span class="MJXp-mi MJXp-bold" id="MJXp-Span-845">x</span></span><span class="MJXp-mo" id="MJXp-Span-846" style="margin-left: 0.333em; margin-right: 0.333em;">∣</span><span class="MJXp-mrow" id="MJXp-Span-847"><span class="MJXp-mrow" id="MJXp-Span-848"><span class="MJXp-munderover" id="MJXp-Span-849"><span><span class="MJXp-over"><span style="margin-bottom: -1.17em;"><span class="MJXp-mo MJXp-bold" id="MJXp-Span-851" style="margin-left: 0px; margin-right: 0px;">˜</span></span><span><span class="MJXp-mi MJXp-bold" id="MJXp-Span-850">x</span></span></span></span></span></span></span><span class="MJXp-mo" id="MJXp-Span-852" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-109">p_\text{reconstruct}(\mathbf{x}\mid\mathbf{\widetilde x})</script></span> được ước lượng từ các cặp huấn luyện <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-853"><span class="MJXp-mo" id="MJXp-Span-854" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mrow" id="MJXp-Span-855"><span class="MJXp-mi MJXp-bold" id="MJXp-Span-856">x</span></span><span class="MJXp-mo" id="MJXp-Span-857" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mrow" id="MJXp-Span-858"><span class="MJXp-mrow" id="MJXp-Span-859"><span class="MJXp-munderover" id="MJXp-Span-860"><span><span class="MJXp-over"><span style="margin-bottom: -1.17em;"><span class="MJXp-mo MJXp-bold" id="MJXp-Span-862" style="margin-left: 0px; margin-right: 0px;">˜</span></span><span><span class="MJXp-mi MJXp-bold" id="MJXp-Span-861">x</span></span></span></span></span></span></span><span class="MJXp-mo" id="MJXp-Span-863" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-110">(\mathbf{x}, \mathbf{\widetilde x})</script></span> bằng các bước sau:</p><ol>
<li>Lấy một mẫu huấn luyện <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-864"><span class="MJXp-mrow" id="MJXp-Span-865"><span class="MJXp-mi MJXp-bold" id="MJXp-Span-866">x</span></span></span></span><script type="math/tex" id="MathJax-Element-111">\mathbf{x}</script></span> từ dữ liệu huấn luyện.</li>
<li>Lấy một mẫu phiên bản bị sửa đổi <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-867"><span class="MJXp-mrow" id="MJXp-Span-868"><span class="MJXp-mrow" id="MJXp-Span-869"><span class="MJXp-munderover" id="MJXp-Span-870"><span><span class="MJXp-over"><span style="margin-bottom: -1.17em;"><span class="MJXp-mo MJXp-bold" id="MJXp-Span-872" style="margin-left: 0px; margin-right: 0px;">˜</span></span><span><span class="MJXp-mi MJXp-bold" id="MJXp-Span-871">x</span></span></span></span></span></span></span></span></span><script type="math/tex" id="MathJax-Element-112">\mathbf{\widetilde x}</script></span> từ <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-873"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-874">C</span><span class="MJXp-mo" id="MJXp-Span-875" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mrow" id="MJXp-Span-876"><span class="MJXp-mrow" id="MJXp-Span-877"><span class="MJXp-munderover" id="MJXp-Span-878"><span><span class="MJXp-over"><span style="margin-bottom: -1.17em;"><span class="MJXp-mo MJXp-bold" id="MJXp-Span-880" style="margin-left: 0px; margin-right: 0px;">˜</span></span><span><span class="MJXp-mi MJXp-bold" id="MJXp-Span-879">x</span></span></span></span></span></span></span><span class="MJXp-mo" id="MJXp-Span-881" style="margin-left: 0.333em; margin-right: 0.333em;">∣</span><span class="MJXp-mrow" id="MJXp-Span-882"><span class="MJXp-mi MJXp-bold" id="MJXp-Span-883">x</span></span><span class="MJXp-mo" id="MJXp-Span-884" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-885">x</span><span class="MJXp-mo" id="MJXp-Span-886" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-113">C(\mathbf{\widetilde x} \mid\mathbf{x} = \boldsymbol x)</script></span>.</li>
<li>Sử dụng <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-887"><span class="MJXp-mo" id="MJXp-Span-888" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-889">x</span><span class="MJXp-mo" id="MJXp-Span-890" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mrow" id="MJXp-Span-891"><span class="MJXp-munderover" id="MJXp-Span-892"><span><span class="MJXp-over"><span style="margin-bottom: -1.17em;"><span class="MJXp-mo MJXp-bold" id="MJXp-Span-894" style="margin-left: 0px; margin-right: 0px;">˜</span></span><span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-893">x</span></span></span></span></span></span><span class="MJXp-mo" id="MJXp-Span-895" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-114">(\boldsymbol x, \boldsymbol{\widetilde x})</script></span> làm mẫu huấn luyện để ước lượng phân phối tái thiết <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-896"><span class="MJXp-msubsup" id="MJXp-Span-897"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-898" style="margin-right: 0.05em;">p</span><span class="MJXp-mtext MJXp-script" id="MJXp-Span-899" style="vertical-align: -0.4em;">reconstruct</span></span><span class="MJXp-mo" id="MJXp-Span-900" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-901">x</span><span class="MJXp-mo" id="MJXp-Span-902" style="margin-left: 0.333em; margin-right: 0.333em;">∣</span><span class="MJXp-mrow" id="MJXp-Span-903"><span class="MJXp-munderover" id="MJXp-Span-904"><span><span class="MJXp-over"><span style="margin-bottom: -1.17em;"><span class="MJXp-mo MJXp-bold" id="MJXp-Span-906" style="margin-left: 0px; margin-right: 0px;">˜</span></span><span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-905">x</span></span></span></span></span></span><span class="MJXp-mo" id="MJXp-Span-907" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-908" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-msubsup" id="MJXp-Span-909"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-910" style="margin-right: 0.05em;">p</span><span class="MJXp-mtext MJXp-script" id="MJXp-Span-911" style="vertical-align: -0.4em;">decoder</span></span><span class="MJXp-mo" id="MJXp-Span-912" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-913">x</span><span class="MJXp-mo" id="MJXp-Span-914" style="margin-left: 0.333em; margin-right: 0.333em;">∣</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-915">h</span><span class="MJXp-mo" id="MJXp-Span-916" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-115">p_\text{reconstruct}(\boldsymbol x\mid\boldsymbol{\widetilde x}) = p_\text{decoder}(\boldsymbol x\mid\boldsymbol h)</script></span> của bộ tự mã hóa với <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-917"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-918">h</span></span></span><script type="math/tex" id="MathJax-Element-116">\boldsymbol h</script></span> là đầu ra của bộ mã hóa <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-919"><span class="MJXp-mrow" id="MJXp-Span-920"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-921">f</span></span><span class="MJXp-mo" id="MJXp-Span-922" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mrow" id="MJXp-Span-923"><span class="MJXp-munderover" id="MJXp-Span-924"><span><span class="MJXp-over"><span style="margin-bottom: -1.17em;"><span class="MJXp-mo MJXp-bold" id="MJXp-Span-926" style="margin-left: 0px; margin-right: 0px;">˜</span></span><span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-925">x</span></span></span></span></span></span><span class="MJXp-mo" id="MJXp-Span-927" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-117">\mathcal{f}(\boldsymbol{\widetilde x})</script></span> và <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-928"><span class="MJXp-msubsup" id="MJXp-Span-929"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-930" style="margin-right: 0.05em;">p</span><span class="MJXp-mtext MJXp-script" id="MJXp-Span-931" style="vertical-align: -0.4em;">decoder</span></span></span></span><script type="math/tex" id="MathJax-Element-118">p_\text{decoder}</script></span> thường được xác định bởi một hàm giải mã <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-932"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-933">g</span><span class="MJXp-mo" id="MJXp-Span-934" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-935">h</span><span class="MJXp-mo" id="MJXp-Span-936" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-119">g(\boldsymbol h)</script></span></li>
</ol><p><img src="https://i.imgur.com/aly08m4.png" alt=""></p><blockquote>
<p>Hình 14.3: Đồ thị tính toán của hàm chi phí của một bộ tự mã hóa khử nhiễu, được huấn luyện để tái thiết điểm dữ liệu sạch <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-937"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-938">x</span></span></span><script type="math/tex" id="MathJax-Element-120">\boldsymbol x</script></span> từ phiên bản được sửa đổi <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-939"><span class="MJXp-mrow" id="MJXp-Span-940"><span class="MJXp-munderover" id="MJXp-Span-941"><span><span class="MJXp-over"><span style="margin-bottom: -1.17em;"><span class="MJXp-mo MJXp-bold" id="MJXp-Span-943" style="margin-left: 0px; margin-right: 0px;">˜</span></span><span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-942">x</span></span></span></span></span></span></span></span><script type="math/tex" id="MathJax-Element-121">\boldsymbol{\widetilde x}</script></span> của nó. Quá trình này được thực hiện bằng cách cực tiểu hóa hàm mất mất <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-944"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-945">L</span><span class="MJXp-mo" id="MJXp-Span-946" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mo" id="MJXp-Span-947" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-mi" id="MJXp-Span-948">log</span><span class="MJXp-mo" id="MJXp-Span-949" style="margin-left: 0em; margin-right: 0em;"></span><span class="MJXp-msubsup" id="MJXp-Span-950"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-951" style="margin-right: 0.05em;">p</span><span class="MJXp-mtext MJXp-script" id="MJXp-Span-952" style="vertical-align: -0.4em;">decoder</span></span><span class="MJXp-mo" id="MJXp-Span-953" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-954">x</span><span class="MJXp-mo" id="MJXp-Span-955" style="margin-left: 0.333em; margin-right: 0.333em;">∣</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-956">h</span><span class="MJXp-mo" id="MJXp-Span-957" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-958">f</span><span class="MJXp-mo" id="MJXp-Span-959" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mrow" id="MJXp-Span-960"><span class="MJXp-munderover" id="MJXp-Span-961"><span><span class="MJXp-over"><span style="margin-bottom: -1.17em;"><span class="MJXp-mo MJXp-bold" id="MJXp-Span-963" style="margin-left: 0px; margin-right: 0px;">˜</span></span><span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-962">x</span></span></span></span></span></span><span class="MJXp-mo" id="MJXp-Span-964" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-965" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-122">L=-\log p_\text{decoder}(\boldsymbol x\mid\boldsymbol h = f(\boldsymbol{\widetilde x}))</script></span>, trong đó <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-966"><span class="MJXp-mrow" id="MJXp-Span-967"><span class="MJXp-munderover" id="MJXp-Span-968"><span><span class="MJXp-over"><span style="margin-bottom: -1.17em;"><span class="MJXp-mo MJXp-bold" id="MJXp-Span-970" style="margin-left: 0px; margin-right: 0px;">˜</span></span><span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-969">x</span></span></span></span></span></span></span></span><script type="math/tex" id="MathJax-Element-123">\boldsymbol{\widetilde x}</script></span> là phiên bản sửa đổi của <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-971"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-972">x</span></span></span><script type="math/tex" id="MathJax-Element-124">\boldsymbol x</script></span> thu được từ một quá trình sửa đổi <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-973"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-974">C</span><span class="MJXp-mo" id="MJXp-Span-975" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mrow" id="MJXp-Span-976"><span class="MJXp-munderover" id="MJXp-Span-977"><span><span class="MJXp-over"><span style="margin-bottom: -1.17em;"><span class="MJXp-mo MJXp-bold" id="MJXp-Span-979" style="margin-left: 0px; margin-right: 0px;">˜</span></span><span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-978">x</span></span></span></span></span></span><span class="MJXp-mo" id="MJXp-Span-980" style="margin-left: 0.333em; margin-right: 0.333em;">∣</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-981">x</span><span class="MJXp-mo" id="MJXp-Span-982" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-125">C (\boldsymbol{\widetilde x}\mid\boldsymbol x)</script></span> cho trước. Thông thường, phân phối <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-983"><span class="MJXp-msubsup" id="MJXp-Span-984"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-985" style="margin-right: 0.05em;">p</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-986" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-987">d</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-988">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-989">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-990">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-991">d</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-992">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-993">r</span></span></span></span></span><script type="math/tex" id="MathJax-Element-126">p_{decoder}</script></span> là một <a href="https://www.statisticshowto.datasciencecentral.com/factorial-distribution/" target="_blank" rel="noopener">phân phối nhân tố</a> có các tham số giá trị trung bình được tính bởi một mạng lan truyền thuận <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-994"><span class="MJXp-mrow" id="MJXp-Span-995"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-996">g</span></span></span></span><script type="math/tex" id="MathJax-Element-127">\mathcal{g}</script></span>.</p>
</blockquote><p>Chúng ta thường chỉ xấp xỉ giá trị cực tiểu của số đối logarit hàm hợp lý <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-997"><span class="MJXp-mo" id="MJXp-Span-998" style="margin-left: 0em; margin-right: 0.111em;">−</span><span class="MJXp-mi" id="MJXp-Span-999">log</span><span class="MJXp-mo" id="MJXp-Span-1000" style="margin-left: 0em; margin-right: 0em;"></span><span class="MJXp-msubsup" id="MJXp-Span-1001"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1002" style="margin-right: 0.05em;">p</span><span class="MJXp-mtext MJXp-script" id="MJXp-Span-1003" style="vertical-align: -0.4em;">decoder</span></span><span class="MJXp-mo" id="MJXp-Span-1004" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1005">x</span><span class="MJXp-mo" id="MJXp-Span-1006" style="margin-left: 0.333em; margin-right: 0.333em;">∣</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1007">h</span><span class="MJXp-mo" id="MJXp-Span-1008" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-128">-\log p_\text{decoder}(\boldsymbol x\mid\boldsymbol h)</script></span> theo cách đơn giản là dựa trên gradient (chẳng hạn như phép trượt gradient theo lô nhỏ). Bộ tự mã hóa khử nhiễu sẽ là một mạng lan truyền thuận và có thể được huấn luyện bằng các kỹ thuật tương tự như bất kỳ mạng lan truyền thuận nào khác nếu bộ mã hóa là tất định.</p><p>Do đó, ta có thể coi như DAE thực hiện trượt gradient ngẫu nhiên theo giá trị kỳ vọng sau:</p><p><span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-1009"><span class="MJXp-mtable" id="MJXp-Span-1010"><span><span class="MJXp-mlabeledtr" id="MJXp-Span-1011" style="vertical-align: baseline;"><span class="MJXp-mtd" id="MJXp-Span-1012" style="text-align: center;"><span class="MJXp-mo" id="MJXp-Span-1013" style="margin-left: 0em; margin-right: 0.111em;">−</span><span class="MJXp-msubsup" id="MJXp-Span-1014"><span class="MJXp-mrow" id="MJXp-Span-1015" style="margin-right: 0.05em;"><span class="MJXp-mi undefined" id="MJXp-Span-1016">E</span></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-1017" style="vertical-align: -0.4em;"><span class="MJXp-mrow" id="MJXp-Span-1018"><span class="MJXp-mi MJXp-bold" id="MJXp-Span-1019">x</span></span><span class="MJXp-mo" id="MJXp-Span-1020">∼</span><span class="MJXp-msubsup" id="MJXp-Span-1021"><span class="MJXp-mrow" id="MJXp-Span-1022" style="margin-right: 0.05em;"><span class="MJXp-munderover" id="MJXp-Span-1023"><span><span class="MJXp-over"><span class="MJXp-script" style="margin-bottom: -1.17em;"><span class="MJXp-mo" id="MJXp-Span-1025" style="margin-right: 0px; margin-left: 0px;">ˆ</span></span><span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1024">p</span></span></span></span></span></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-1026" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1027">d</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1028">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1029">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1030">a</span></span></span><span class="MJXp-mo" id="MJXp-Span-1031">(</span><span class="MJXp-mrow" id="MJXp-Span-1032"><span class="MJXp-mi MJXp-bold" id="MJXp-Span-1033">x</span></span><span class="MJXp-mo" id="MJXp-Span-1034">)</span></span></span><span class="MJXp-msubsup" id="MJXp-Span-1035"><span class="MJXp-mrow" id="MJXp-Span-1036" style="margin-right: 0.05em;"><span class="MJXp-mi undefined" id="MJXp-Span-1037">E</span></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-1038" style="vertical-align: -0.4em;"><span class="MJXp-mrow" id="MJXp-Span-1039"><span class="MJXp-munderover" id="MJXp-Span-1040"><span><span class="MJXp-over"><span class="MJXp-script" style="margin-bottom: -1.17em;"><span class="MJXp-mo" id="MJXp-Span-1043" style="margin-right: 0px; margin-left: 0px;">ˆ</span></span><span><span class="MJXp-mrow" id="MJXp-Span-1041"><span class="MJXp-mi MJXp-bold" id="MJXp-Span-1042">x</span></span></span></span></span></span></span><span class="MJXp-mo" id="MJXp-Span-1044">∼</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1045">C</span><span class="MJXp-mo" id="MJXp-Span-1046">(</span><span class="MJXp-mrow" id="MJXp-Span-1047"><span class="MJXp-mrow" id="MJXp-Span-1048"><span class="MJXp-munderover" id="MJXp-Span-1049"><span><span class="MJXp-over"><span class="MJXp-script" style="margin-bottom: -1.17em;"><span class="MJXp-mo MJXp-bold" id="MJXp-Span-1051" style="margin-right: 0px; margin-left: 0px;">˜</span></span><span><span class="MJXp-mi MJXp-bold" id="MJXp-Span-1050">x</span></span></span></span></span></span></span><span class="MJXp-mo" id="MJXp-Span-1052">∣</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1053">x</span><span class="MJXp-mo" id="MJXp-Span-1054">)</span></span></span><span class="MJXp-mi" id="MJXp-Span-1055">log</span><span class="MJXp-mo" id="MJXp-Span-1056" style="margin-left: 0em; margin-right: 0em;"></span><span class="MJXp-msubsup" id="MJXp-Span-1057"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1058" style="margin-right: 0.05em;">p</span><span class="MJXp-mtext MJXp-script" id="MJXp-Span-1059" style="vertical-align: -0.4em;">decoder</span></span><span class="MJXp-mo" id="MJXp-Span-1060" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1061">x</span><span class="MJXp-mo" id="MJXp-Span-1062" style="margin-left: 0.333em; margin-right: 0.333em;">∣</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1063">h</span><span class="MJXp-mo" id="MJXp-Span-1064" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1065">f</span><span class="MJXp-mo" id="MJXp-Span-1066" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mrow" id="MJXp-Span-1067"><span class="MJXp-munderover" id="MJXp-Span-1068"><span><span class="MJXp-over"><span style="margin-bottom: -1.17em;"><span class="MJXp-mo MJXp-bold" id="MJXp-Span-1070" style="margin-left: 0px; margin-right: 0px;">˜</span></span><span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1069">x</span></span></span></span></span></span><span class="MJXp-mo" id="MJXp-Span-1071" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-1072" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-1073" style="margin-left: 0em; margin-right: 0.222em;">,</span></span></span></span></span></span></span><script type="math/tex; mode=display" id="MathJax-Element-129"> -\mathbb{E}_{\mathbf{x} \sim \hat{p}_{data}(\mathbf{x})}\mathbb{E}_{\hat{\mathbf{x}} \sim C(\mathbf{\widetilde x}\mid\boldsymbol x)}\log p_\text{decoder}(\boldsymbol x \mid \boldsymbol h = f(\boldsymbol{\widetilde x})), \tag{14.14} </script></span></p><p>trong đó <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1074"><span class="MJXp-msubsup" id="MJXp-Span-1075"><span class="MJXp-mrow" id="MJXp-Span-1076" style="margin-right: 0.05em;"><span class="MJXp-munderover" id="MJXp-Span-1077"><span><span class="MJXp-over"><span style="margin-bottom: -1.17em;"><span class="MJXp-mo" id="MJXp-Span-1079" style="margin-left: 0px; margin-right: 0px;">ˆ</span></span><span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1078">p</span></span></span></span></span></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-1080" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1081">d</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1082">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1083">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1084">a</span></span></span><span class="MJXp-mo" id="MJXp-Span-1085" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mrow" id="MJXp-Span-1086"><span class="MJXp-mi MJXp-bold" id="MJXp-Span-1087">x</span></span><span class="MJXp-mo" id="MJXp-Span-1088" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-130">\hat{p}_{data}(\mathbf{x})</script></span> là phân phối huấn luyện.</p><p>------------------------<br>
Lại Minh Duy kết thúc dịch từ đây<br>
------------------------</p><p>// ------ Sơn Lâm bắt đầu dịch từ đây p509 - p512</p><h3 id="1451-Ước-lượng-điểm-số"><a class="anchor hidden-xs" href="#1451-Ước-lượng-điểm-số" title="1451-Ước-lượng-điểm-số"><span class="octicon octicon-link"></span></a>14.5.1 Ước lượng điểm số</h3><p>So sánh điểm số (Hyvärinen, 2005) là một thuật toán thay thế cho hợp lý cực đại. Nó cung cấp một ước lượng nhất quán của các phân phối xác suất dựa trên việc khuyến khích mô hình có cùng <em>điểm số</em> (score) với phân phối dữ liệu tại mỗi điểm huấn luyện <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1089"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1090">x</span></span></span><script type="math/tex" id="MathJax-Element-131">\boldsymbol{x}</script></span>. Ở đây, điểm số là một trường gradient cụ thể:</p><p><span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-1091"><span class="MJXp-mtable" id="MJXp-Span-1092"><span><span class="MJXp-mlabeledtr" id="MJXp-Span-1093" style="vertical-align: baseline;"><span class="MJXp-mtd" id="MJXp-Span-1094" style="text-align: right;"><span class="MJXp-msubsup" id="MJXp-Span-1095"><span class="MJXp-mi" id="MJXp-Span-1096" style="margin-right: 0.05em;">∇</span><span class="MJXp-mi MJXp-bold MJXp-italic MJXp-script" id="MJXp-Span-1097" style="vertical-align: -0.4em;">x</span></span><span class="MJXp-mi" id="MJXp-Span-1098">log</span><span class="MJXp-mo" id="MJXp-Span-1099" style="margin-left: 0em; margin-right: 0em;"></span><span class="MJXp-mtext" id="MJXp-Span-1100">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1101">p</span><span class="MJXp-mo" id="MJXp-Span-1102" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1103">x</span><span class="MJXp-mo" id="MJXp-Span-1104" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-1105" style="margin-left: 0em; margin-right: 0.222em;">.</span></span></span></span></span></span></span><script type="math/tex; mode=display" id="MathJax-Element-132">\begin{align}
    \nabla_\boldsymbol{x} \log\space p(\boldsymbol{x}).
    \tag{14.15}
\end{align}</script></span><br>
Thuật toán so sánh điểm số sẽ được thảo luận sâu hơn ở phần 18.4. Trong chương này, ta chỉ cần hiểu rằng việc học trường gradient <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1106"><span class="MJXp-mi" id="MJXp-Span-1107">log</span><span class="MJXp-mo" id="MJXp-Span-1108" style="margin-left: 0em; margin-right: 0em;"></span><span class="MJXp-mtext" id="MJXp-Span-1109">&nbsp;</span><span class="MJXp-msubsup" id="MJXp-Span-1110"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1111" style="margin-right: 0.05em;">p</span><span class="MJXp-mtext MJXp-script" id="MJXp-Span-1112" style="vertical-align: -0.4em;">data</span></span></span></span><script type="math/tex" id="MathJax-Element-133">\log\space p_\text{data}</script></span> là một cách để học cấu trúc của chính <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1113"><span class="MJXp-msubsup" id="MJXp-Span-1114"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1115" style="margin-right: 0.05em;">p</span><span class="MJXp-mtext MJXp-script" id="MJXp-Span-1116" style="vertical-align: -0.4em;">data</span></span></span></span><script type="math/tex" id="MathJax-Element-134">p_\text{data}</script></span>.</p><p>Một thuộc tính rất quan trọng của DAE đó là tiêu chuẩn huấn luyện của chúng (với phân bố Gauss có điều kiện <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1117"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1118">p</span><span class="MJXp-mo" id="MJXp-Span-1119" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1120">x</span><span class="MJXp-mo" id="MJXp-Span-1121" style="margin-left: 0.333em; margin-right: 0.333em;">∣</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1122">h</span><span class="MJXp-mo" id="MJXp-Span-1123" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-135">p(\boldsymbol{x} \mid \boldsymbol{h})</script></span>) sẽ khiến các bộ tự mã hóa học một trường vector <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1124"><span class="MJXp-mo" id="MJXp-Span-1125" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mrow" id="MJXp-Span-1126"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-1127">g</span></span><span class="MJXp-mo" id="MJXp-Span-1128" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mrow" id="MJXp-Span-1129"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-1130">f</span></span><span class="MJXp-mo" id="MJXp-Span-1131" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1132">x</span><span class="MJXp-mo" id="MJXp-Span-1133" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-1134" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-1135" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1136">x</span><span class="MJXp-mo" id="MJXp-Span-1137" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-136">(\mathcal{g}(\mathcal{f}(\boldsymbol{x})) - \boldsymbol{x})</script></span> giúp ước lượng các điểm số của phân phối dữ liệu. Điều này được minh họa trong hình 14.4.</p><p><img src="https://i.imgur.com/STr5DXv.png" alt=""></p><blockquote>
<p>Hình 14.4: Một bộ tự mã hóa khử nhiễu được huấn luyện để ánh xạ điểm dữ liệu sai hỏng <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1138"><span class="MJXp-mrow" id="MJXp-Span-1139"><span class="MJXp-munderover" id="MJXp-Span-1140"><span><span class="MJXp-over"><span style="margin-bottom: -1.17em;"><span class="MJXp-mo MJXp-bold" id="MJXp-Span-1142" style="margin-left: 0px; margin-right: 0px;">˜</span></span><span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1141">x</span></span></span></span></span></span></span></span><script type="math/tex" id="MathJax-Element-137">\boldsymbol{\widetilde{x}}</script></span> trở lại điểm dữ liệu ban đầu <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1143"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1144">x</span></span></span><script type="math/tex" id="MathJax-Element-138">\boldsymbol{x}</script></span>. Chúng tôi minh hoạ ví dụ huấn luyện <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1145"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1146">x</span></span></span><script type="math/tex" id="MathJax-Element-139">\boldsymbol{x}</script></span> bằng các điểm gạch chéo màu đỏ nằm gần một đa tạp có số chiều thấp, minh hoạ bởi đường màu đen đậm. Quá trình gây sai hỏng <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1147"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1148">C</span><span class="MJXp-mo" id="MJXp-Span-1149" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mrow" id="MJXp-Span-1150"><span class="MJXp-munderover" id="MJXp-Span-1151"><span><span class="MJXp-over"><span style="margin-bottom: -1.17em;"><span class="MJXp-mo MJXp-bold" id="MJXp-Span-1153" style="margin-left: 0px; margin-right: 0px;">˜</span></span><span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1152">x</span></span></span></span></span></span><span class="MJXp-mo" id="MJXp-Span-1154" style="margin-left: 0.333em; margin-right: 0.333em;">∣</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1155">x</span><span class="MJXp-mo" id="MJXp-Span-1156" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-140">C(\boldsymbol{\widetilde{x}} \mid \boldsymbol{x})</script></span> được minh hoạ bằng một đường tròn màu xám chứa tập hợp những điểm sai hỏng có cùng xác suất xảy ra. Mũi tên màu xám thể hiện cách một ví dụ huấn luyện biến đổi thành một mẫu từ quá trình gây sai hỏng này. Khi bộ tự mã hóa khử nhiễu được huấn luyện để cực tiểu hóa trung bình bình phương sai số <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1157"><span class="MJXp-mo" id="MJXp-Span-1158" style="margin-left: 0em; margin-right: 0em;">‖</span><span class="MJXp-mrow" id="MJXp-Span-1159"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-1160">g</span></span><span class="MJXp-mo" id="MJXp-Span-1161" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mrow" id="MJXp-Span-1162"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-1163">f</span></span><span class="MJXp-mo" id="MJXp-Span-1164" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mrow" id="MJXp-Span-1165"><span class="MJXp-munderover" id="MJXp-Span-1166"><span><span class="MJXp-over"><span style="margin-bottom: -1.17em;"><span class="MJXp-mo MJXp-bold" id="MJXp-Span-1168" style="margin-left: 0px; margin-right: 0px;">˜</span></span><span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1167">x</span></span></span></span></span></span><span class="MJXp-mo" id="MJXp-Span-1169" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-1170" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1171">x</span><span class="MJXp-mo" id="MJXp-Span-1172" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-msubsup" id="MJXp-Span-1173"><span class="MJXp-mo" id="MJXp-Span-1174" style="margin-left: 0em; margin-right: 0.05em;">‖</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-1175" style="vertical-align: 0.5em;">2</span></span></span></span><script type="math/tex" id="MathJax-Element-141">\| \mathcal{g}(\mathcal{f}(\boldsymbol{\widetilde{x}}) - \boldsymbol{x})\|^2</script></span>, hàm tái thiết <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1176"><span class="MJXp-mrow" id="MJXp-Span-1177"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-1178">g</span></span><span class="MJXp-mo" id="MJXp-Span-1179" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mrow" id="MJXp-Span-1180"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-1181">f</span></span><span class="MJXp-mo" id="MJXp-Span-1182" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mrow" id="MJXp-Span-1183"><span class="MJXp-munderover" id="MJXp-Span-1184"><span><span class="MJXp-over"><span style="margin-bottom: -1.17em;"><span class="MJXp-mo MJXp-bold" id="MJXp-Span-1186" style="margin-left: 0px; margin-right: 0px;">˜</span></span><span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1185">x</span></span></span></span></span></span><span class="MJXp-mo" id="MJXp-Span-1187" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-1188" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-142">\mathcal{g}(\mathcal{f}(\boldsymbol{\widetilde{x}}))</script></span> sẽ ước lượng <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1189"><span class="MJXp-msubsup" id="MJXp-Span-1190"><span class="MJXp-mrow" id="MJXp-Span-1191" style="margin-right: 0.05em;"><span class="MJXp-mi undefined" id="MJXp-Span-1192">E</span></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-1193" style="vertical-align: -0.4em;"><span class="MJXp-mrow" id="MJXp-Span-1194"><span class="MJXp-mi" id="MJXp-Span-1195">x</span></span><span class="MJXp-mo" id="MJXp-Span-1196">,</span><span class="MJXp-mrow" id="MJXp-Span-1197"><span class="MJXp-mrow" id="MJXp-Span-1198"><span class="MJXp-munderover" id="MJXp-Span-1199"><span><span class="MJXp-over"><span class="MJXp-script" style="margin-bottom: -1.17em;"><span class="MJXp-mo" id="MJXp-Span-1201" style="margin-right: 0px; margin-left: 0px;">˜</span></span><span><span class="MJXp-mi" id="MJXp-Span-1200">x</span></span></span></span></span></span></span><span class="MJXp-mo" id="MJXp-Span-1202">∼</span><span class="MJXp-msubsup" id="MJXp-Span-1203"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1204" style="margin-right: 0.05em;">p</span><span class="MJXp-mtext MJXp-script" id="MJXp-Span-1205" style="vertical-align: -0.4em;">data</span></span><span class="MJXp-mo" id="MJXp-Span-1206">(</span><span class="MJXp-mrow" id="MJXp-Span-1207"><span class="MJXp-mi" id="MJXp-Span-1208">x</span></span><span class="MJXp-mo" id="MJXp-Span-1209">)</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1210">C</span><span class="MJXp-mo" id="MJXp-Span-1211">(</span><span class="MJXp-mrow" id="MJXp-Span-1212"><span class="MJXp-mrow" id="MJXp-Span-1213"><span class="MJXp-munderover" id="MJXp-Span-1214"><span><span class="MJXp-over"><span class="MJXp-script" style="margin-bottom: -1.17em;"><span class="MJXp-mo" id="MJXp-Span-1216" style="margin-right: 0px; margin-left: 0px;">˜</span></span><span><span class="MJXp-mi" id="MJXp-Span-1215">x</span></span></span></span></span></span></span><span class="MJXp-mo" id="MJXp-Span-1217">∣</span><span class="MJXp-mrow" id="MJXp-Span-1218"><span class="MJXp-mi" id="MJXp-Span-1219">x</span></span><span class="MJXp-mo" id="MJXp-Span-1220">)</span></span></span><span class="MJXp-mrow" id="MJXp-Span-1221"><span class="MJXp-mo" id="MJXp-Span-1222" style="margin-left: 0em; margin-right: 0em; vertical-align: -0.124em;"><span class="MJXp-right MJXp-scale9" style="font-size: 1.498em; margin-left: 0.03em;">[</span></span><span class="MJXp-mrow" id="MJXp-Span-1223"><span class="MJXp-mi" id="MJXp-Span-1224">x</span></span><span class="MJXp-mo" id="MJXp-Span-1225" style="margin-left: 0.333em; margin-right: 0.333em;">∣</span><span class="MJXp-mrow" id="MJXp-Span-1226"><span class="MJXp-munderover" id="MJXp-Span-1227"><span><span class="MJXp-over"><span style="margin-bottom: -1.17em;"><span class="MJXp-mo" id="MJXp-Span-1229" style="margin-left: 0px; margin-right: 0px;">˜</span></span><span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1228">x</span></span></span></span></span></span><span class="MJXp-mo" id="MJXp-Span-1230" style="margin-left: 0em; margin-right: 0em; vertical-align: -0.124em;"><span class="MJXp-right MJXp-scale9" style="font-size: 1.498em; margin-left: 0.03em;">]</span></span></span></span></span><script type="math/tex" id="MathJax-Element-143">\mathbb{E}_{\mathrm{x},\mathrm{\widetilde{x}}\sim p_\text{data}(\mathrm{x})C(\mathrm{\widetilde{x}} \mid \mathrm{x})}\left[\mathrm{x} \mid \widetilde{x}\right]</script></span>. Vector <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1231"><span class="MJXp-mrow" id="MJXp-Span-1232"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-1233">g</span></span><span class="MJXp-mo" id="MJXp-Span-1234" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mrow" id="MJXp-Span-1235"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-1236">f</span></span><span class="MJXp-mo" id="MJXp-Span-1237" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mrow" id="MJXp-Span-1238"><span class="MJXp-munderover" id="MJXp-Span-1239"><span><span class="MJXp-over"><span style="margin-bottom: -1.17em;"><span class="MJXp-mo MJXp-bold" id="MJXp-Span-1241" style="margin-left: 0px; margin-right: 0px;">˜</span></span><span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1240">x</span></span></span></span></span></span><span class="MJXp-mo" id="MJXp-Span-1242" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-1243" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-1244" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-mrow" id="MJXp-Span-1245"><span class="MJXp-munderover" id="MJXp-Span-1246"><span><span class="MJXp-over"><span style="margin-bottom: -1.17em;"><span class="MJXp-mo MJXp-bold" id="MJXp-Span-1248" style="margin-left: 0px; margin-right: 0px;">˜</span></span><span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1247">x</span></span></span></span></span></span></span></span><script type="math/tex" id="MathJax-Element-144">\mathcal{g}(\mathcal{f} (\boldsymbol{\widetilde{x}})) - \boldsymbol{\widetilde{x}}</script></span>, một cách xấp xỉ, trỏ tới điểm gần nhất trên đa tạp, vì <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1249"><span class="MJXp-mrow" id="MJXp-Span-1250"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-1251">g</span></span><span class="MJXp-mo" id="MJXp-Span-1252" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mrow" id="MJXp-Span-1253"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-1254">f</span></span><span class="MJXp-mo" id="MJXp-Span-1255" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mrow" id="MJXp-Span-1256"><span class="MJXp-munderover" id="MJXp-Span-1257"><span><span class="MJXp-over"><span style="margin-bottom: -1.17em;"><span class="MJXp-mo MJXp-bold" id="MJXp-Span-1259" style="margin-left: 0px; margin-right: 0px;">˜</span></span><span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1258">x</span></span></span></span></span></span><span class="MJXp-mo" id="MJXp-Span-1260" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-1261" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-145">\mathcal{g}(\mathcal{f}(\boldsymbol{\widetilde{x}}))</script></span> sẽ ước lượng tâm của khối các điểm sạch <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1262"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1263">x</span></span></span><script type="math/tex" id="MathJax-Element-146">\boldsymbol{x}</script></span>  có thể sinh ra <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1264"><span class="MJXp-mrow" id="MJXp-Span-1265"><span class="MJXp-munderover" id="MJXp-Span-1266"><span><span class="MJXp-over"><span style="margin-bottom: -1.17em;"><span class="MJXp-mo" id="MJXp-Span-1268" style="margin-left: 0px; margin-right: 0px;">˜</span></span><span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1267">x</span></span></span></span></span></span></span></span><script type="math/tex" id="MathJax-Element-147">\widetilde{x}</script></span>. Do đó, bộ tự mã hóa học một trường vector \mathcal{g}(\mathcal{f}(\boldsymbol{x})) - \boldsymbol{x}$ được biểu diễn bằng các mũi tên màu xanh lá cây. Trường vector này ước lượng điểm số <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1269"><span class="MJXp-msubsup" id="MJXp-Span-1270"><span class="MJXp-mi" id="MJXp-Span-1271" style="margin-right: 0.05em;">∇</span><span class="MJXp-mi MJXp-bold MJXp-italic MJXp-script" id="MJXp-Span-1272" style="vertical-align: -0.4em;">x</span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1273">l</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1274">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1275">g</span><span class="MJXp-mtext" id="MJXp-Span-1276">&nbsp;</span><span class="MJXp-msubsup" id="MJXp-Span-1277"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1278" style="margin-right: 0.05em;">p</span><span class="MJXp-mtext MJXp-script" id="MJXp-Span-1279" style="vertical-align: -0.4em;">data</span></span><span class="MJXp-mo" id="MJXp-Span-1280" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1281">x</span><span class="MJXp-mo" id="MJXp-Span-1282" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-148">\nabla_\boldsymbol{x}log\space p_\text{data}(\boldsymbol{x})</script></span> cho đến một thừa số là trung bình căn của giá trị trung bình bình phương sai số tái thiết.</p>
</blockquote><p>Quá trình huấn luyện khử nhiễu của một loại bộ tự mã hóa đặc biệt (các đơn vị ẩn hình chữ S, các đơn vị tuyến tính tái thiết) sử dụng nhiễu sinh bởi phân phối Gauss và trung bình bình phương sai số làm chi phí tái thiết (Vincent, 2011) tương đương với quá trình huấn luyện một mô hình xác suất vô hướng được gọi là RBM với các đơn vị Gauss khả kiến. Loại mô hình sẽ được mô tả chi tiết trong phần 20.5.1; trong phần này, ta chỉ cần hiểu rằng đó là một mô hình cung cấp một phân phối tường minh <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1283"><span class="MJXp-msubsup" id="MJXp-Span-1284"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1285" style="margin-right: 0.05em;">p</span><span class="MJXp-mtext MJXp-script" id="MJXp-Span-1286" style="vertical-align: -0.4em;">model</span></span><span class="MJXp-mo" id="MJXp-Span-1287" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1288">x</span><span class="MJXp-mo" id="MJXp-Span-1289" style="margin-left: 0em; margin-right: 0.222em;">;</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1290">θ</span></span></span><script type="math/tex" id="MathJax-Element-149">p_\text{model}(\boldsymbol{x};\boldsymbol\theta</script></span>). Khi RBM được huấn luyện bằng cách sử dụng <em>so sánh điểm số khử nhiễu</em> (denosing score matching) (Kingma và LeCun, 2010), thuật toán học của nó sẽ tương đương với quá trình huấn luyện khử nhiễu trong bộ tự mã hóa tương ứng. Với một mức độ nhiễu cố định, so sánh điểm có kiểm soát là một ước lượng không nhất quán; thay vào đó, nó khôi phục một phiên bản mờ của phân phối. Nếu mức độ nhiễu được chọn là tiệm cận <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1291"><span class="MJXp-mn" id="MJXp-Span-1292">0</span></span></span><script type="math/tex" id="MathJax-Element-150">0</script></span> trong khi số lượng ví dụ tiệm cận tới vô cực, tính nhất quán được phục hồi. So sánh điểm số khử nhiễu sẽ được thảo luận chi tiết hơn ở phần 18.5.</p><p>Tồn tại các mối liên hệ khác giữa bộ tự mã hóa và các RBM. Thuật toán so sánh điểm số áp dụng cho các RBM tạo ra một hàm chi phí tương tự như sai số tái thiết được kết hợp với một số hạng kiểm soát giống với mức phạt chèn ép của CAE (Sersky <em>et al</em>, 2011). Bengio và Delallean (2009) đã chứng minh rằng gradient của bộ tự mã hóa cho ta một xấp xỉ của quá trình huấn luyện phân kỳ tương phản (contrastive divergence traning) của các RBM.</p><p>Đối với <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1293"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1294">x</span></span></span><script type="math/tex" id="MathJax-Element-151">\boldsymbol{x}</script></span> có giá trị liên tục, tiêu chuẩn khử nhiễu với sai hỏng sinh bởi phân bố Gauss và phân phối tái thiết tạo ra một ước lượng cho điểm số, ước lượng này có thể được áp dụng cho việc tham số hóa bộ mã hóa và bộ giải mã thông thường (Alain and Bengio, 2013). Điều này có nghĩa là kiến trúc tổng quan của bộ mã hóa và giải mã có thể được cài đặt để ước lượng điểm số bằng cách huấn luyện với tiêu chuẩn là bình phương sai số</p><p><span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-1295"><span class="MJXp-mtable" id="MJXp-Span-1296"><span><span class="MJXp-mlabeledtr" id="MJXp-Span-1297" style="vertical-align: baseline;"><span class="MJXp-mtd" id="MJXp-Span-1298" style="text-align: right;"><span class="MJXp-mo" id="MJXp-Span-1299" style="margin-left: 0em; margin-right: 0em;">‖</span><span class="MJXp-mrow" id="MJXp-Span-1300"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-1301">g</span></span><span class="MJXp-mo" id="MJXp-Span-1302" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mrow" id="MJXp-Span-1303"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-1304">f</span></span><span class="MJXp-mo" id="MJXp-Span-1305" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mrow" id="MJXp-Span-1306"><span class="MJXp-munderover" id="MJXp-Span-1307"><span><span class="MJXp-over"><span style="margin-bottom: -1.17em;"><span class="MJXp-mo MJXp-bold" id="MJXp-Span-1309" style="margin-left: 0px; margin-right: 0px;">˜</span></span><span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1308">x</span></span></span></span></span></span><span class="MJXp-mo" id="MJXp-Span-1310" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-1311" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1312">x</span><span class="MJXp-mo" id="MJXp-Span-1313" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-msubsup" id="MJXp-Span-1314"><span class="MJXp-mo" id="MJXp-Span-1315" style="margin-left: 0em; margin-right: 0.05em;">‖</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-1316" style="vertical-align: 0.5em;">2</span></span></span></span></span></span></span></span><script type="math/tex; mode=display" id="MathJax-Element-152">\begin{align}
\|\mathcal{g}(\mathcal{f}(\boldsymbol{\widetilde{x}}) - \boldsymbol{x})\|^2
\tag{14.16}
\end{align}</script></span></p><p>và sự sai hỏng</p><p><span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-1317"><span class="MJXp-mtable" id="MJXp-Span-1318"><span><span class="MJXp-mlabeledtr" id="MJXp-Span-1319" style="vertical-align: baseline;"><span class="MJXp-mtd" id="MJXp-Span-1320" style="text-align: right;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1321">C</span><span class="MJXp-mo" id="MJXp-Span-1322" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mrow" id="MJXp-Span-1323"><span class="MJXp-mrow" id="MJXp-Span-1324"><span class="MJXp-munderover" id="MJXp-Span-1325"><span><span class="MJXp-over"><span style="margin-bottom: -1.17em;"><span class="MJXp-mo" id="MJXp-Span-1327" style="margin-left: 0px; margin-right: 0px;">˜</span></span><span><span class="MJXp-mi" id="MJXp-Span-1326">x</span></span></span></span></span></span></span><span class="MJXp-mo" id="MJXp-Span-1328" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mrow" id="MJXp-Span-1329"><span class="MJXp-munderover" id="MJXp-Span-1330"><span><span class="MJXp-over"><span style="margin-bottom: -1.17em;"><span class="MJXp-mo MJXp-bold" id="MJXp-Span-1332" style="margin-left: 0px; margin-right: 0px;">˜</span></span><span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1331">x</span></span></span></span></span></span><span class="MJXp-mo" id="MJXp-Span-1333" style="margin-left: 0.333em; margin-right: 0.333em;">∣</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1334">x</span><span class="MJXp-mo" id="MJXp-Span-1335" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-1336" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mrow" id="MJXp-Span-1337"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-1338">N</span></span><span class="MJXp-mo" id="MJXp-Span-1339" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mrow" id="MJXp-Span-1340"><span class="MJXp-munderover" id="MJXp-Span-1341"><span><span class="MJXp-over"><span style="margin-bottom: -1.17em;"><span class="MJXp-mo MJXp-bold" id="MJXp-Span-1343" style="margin-left: 0px; margin-right: 0px;">˜</span></span><span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1342">x</span></span></span></span></span></span><span class="MJXp-mo" id="MJXp-Span-1344" style="margin-left: 0em; margin-right: 0.222em;">;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1345">μ</span><span class="MJXp-mo" id="MJXp-Span-1346" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1347">x</span><span class="MJXp-mo" id="MJXp-Span-1348" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mi" id="MJXp-Span-1349">Σ</span><span class="MJXp-mo" id="MJXp-Span-1350" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-msubsup" id="MJXp-Span-1351"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1352" style="margin-right: 0.05em;">σ</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-1353" style="vertical-align: 0.5em;">2</span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1354">I</span><span class="MJXp-mo" id="MJXp-Span-1355" style="margin-left: 0em; margin-right: 0em;">)</span></span></span></span></span></span></span><script type="math/tex; mode=display" id="MathJax-Element-153">\begin{align}
C(\mathrm{\widetilde{x}} = \boldsymbol{\widetilde{x}} \mid \boldsymbol{x}) = \mathcal{N}(\boldsymbol{\widetilde{x}};\mu = \boldsymbol{x}, \Sigma = \sigma^2 I)
    \tag{14.17}
\end{align}</script></span><br>
với phương sai nhiễu <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1356"><span class="MJXp-msubsup" id="MJXp-Span-1357"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1358" style="margin-right: 0.05em;">σ</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-1359" style="vertical-align: 0.5em;">2</span></span></span></span><script type="math/tex" id="MathJax-Element-154">\sigma^2</script></span>. Hình 14.5 minh hoạ cách hoạt động của chúng.</p><p>Không có gì đảm bảo rằng hiệu của giá trị hàm tái thiết <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1360"><span class="MJXp-mrow" id="MJXp-Span-1361"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-1362">g</span></span><span class="MJXp-mo" id="MJXp-Span-1363" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mrow" id="MJXp-Span-1364"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-1365">f</span></span><span class="MJXp-mo" id="MJXp-Span-1366" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1367">x</span><span class="MJXp-mo" id="MJXp-Span-1368" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-1369" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-155">\mathcal{g}(\mathcal{f}(\boldsymbol{x}))</script></span> và đầu vào <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1370"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1371">x</span></span></span><script type="math/tex" id="MathJax-Element-156">\boldsymbol{x}</script></span> tương ứng với gradient của bất kỳ hàm nào, chứ chưa nói đến điểm số. Đó là lí do các nghiên cứu ban đầu (Vincen, 2011) được đặc biệt hóa cho các nhóm tham số nhất định, mà ở đó <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1372"><span class="MJXp-mrow" id="MJXp-Span-1373"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-1374">g</span></span><span class="MJXp-mo" id="MJXp-Span-1375" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mrow" id="MJXp-Span-1376"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-1377">f</span></span><span class="MJXp-mo" id="MJXp-Span-1378" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1379">x</span><span class="MJXp-mo" id="MJXp-Span-1380" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-1381" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-1382" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1383">x</span></span></span><script type="math/tex" id="MathJax-Element-157">\mathcal{g}(\mathcal{f}(\boldsymbol{x})) - \boldsymbol{x}</script></span> có thể được tính bằng bằng đạo hàm của một hàm khác. Kamyshanska và Memisevie (2015) đã tổng quát hóa các kết quả của Vincent (2011) bằng cách định nghĩa một họ các bộ tự mã hóa nông sao cho <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1384"><span class="MJXp-mrow" id="MJXp-Span-1385"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-1386">g</span></span><span class="MJXp-mo" id="MJXp-Span-1387" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mrow" id="MJXp-Span-1388"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-1389">f</span></span><span class="MJXp-mo" id="MJXp-Span-1390" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1391">x</span><span class="MJXp-mo" id="MJXp-Span-1392" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-1393" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-1394" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1395">x</span></span></span><script type="math/tex" id="MathJax-Element-158">\mathcal{g}(\mathcal{f}(\boldsymbol{x})) - \boldsymbol{x}</script></span> tương ứng với một điểm số cho toàn bộ các thành viên của họ này.</p><p>Cho đến giờ, chúng tôi mới chỉ mô tả cách mà một bộ tự mã hóa khử nhiễu học để biểu diễn một phân phối xác suất. Tổng quát hơn, người ta có thể mong muốn sử dụng bộ tự mã hóa như một mô hình sinh mẫu và tạo ra các tập mẫu từ phân phối này. Ý tưởng này sẽ được mô tả cụ thể hơn trong phần 20.11.</p><h3 id="14511-Bối-cảnh-lịch-sử"><a class="anchor hidden-xs" href="#14511-Bối-cảnh-lịch-sử" title="14511-Bối-cảnh-lịch-sử"><span class="octicon octicon-link"></span></a>14.5.1.1 Bối cảnh lịch sử</h3><p>Ý tưởng sử dụng các MLP cho việc khử nhiễu được bắt đầu từ những nghiên cứu của LeCun (1987) và Gallinari cùng cộng sự (1987). Behnke (2001) cũng sử dụng mạng hồi quy đê khử nhiễu các bức ảnh. Bộ tự mã hóa khử nhiễu, theo nghĩa nào đó, đơn giản là các MLP được huấn luyện cho việc khử nhiễu. Tuy nhiên, cái tên “Bộ tự mã hóa khử nhiễu” đề cập đến một mô hình được thiết kế không chỉ đơn thuần là học cách khử nhiễu từ một đầu vào, mà nó có thể học cách trích xuất những biểu diễn nội tại như một hiệu ứng phụ của việc học khử nhiễu. Ý tưởng này được tìm ra muộn hơn (Vicent và các cộng sự, 2008, 2010). Những biểu diễn học được có thể được sử dụng để tiền huấn luyện một mạng có giám sát hoặc một mạng không giám sát sâu hơn. Giống như bộ tự mã hóa thưa, bộ mã hóa thưa, bộ tự mã hóa chèn ép và các loại bộ tự mã hóa có kiểm soát khác, mục tiêu chính của các DAE là tìm cách học một bộ mã hóa với dung lượng rất cao nhưng đồng thời ngăn bộ mã hóa và bộ giải mã này học một hàm đồng nhất vô dụng.</p><p>Trước khi mô hình DAE hiện đại xuất hiện, Inayoshi và Kurita (2005) đã khám phá ra một số mục tiêu tương tự với một số phương thức tương tự. Hướng tiếp cận của họ là tối thiểu hóa sai số tái thiết bên cạnh việc tối ưu một hàm mục tiêu có giám sát, trong khi thêm nhiễu vào lớp ẩn của MLP có giám sát nhằm cải thiện khả năng tổng quát hóa. Các phương thức này cơ bản dựa trên một bộ mã hóa tuyến tính, tuy nhiên, nó không thể học các họ hàm mạnh mẽ như DEA hiện đại.</p><p><img src="https://i.imgur.com/EMnpOAV.png" alt=""></p><blockquote>
<p>Hình 14.5: Trường vector học bởi bộ tự mã hóa khử nhiễu xung quanh một đa tạp cong <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1396"><span class="MJXp-mn" id="MJXp-Span-1397">1</span></span></span><script type="math/tex" id="MathJax-Element-159">1</script></span> chiều nằm gần nơi dữ liệu tập trung trong một không gian <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1398"><span class="MJXp-mn" id="MJXp-Span-1399">2</span></span></span><script type="math/tex" id="MathJax-Element-160">2</script></span> chiều. Mỗi mũi tên có độ dài tỉ lệ thuận với độ lớn của giá trị tái thiết trừ đi vector đầu vào của bộ tự mã hóa và mũi tên trỏ tới nơi có xác suất cao hơn theo phân phối xác suất được ước lượng ngầm định. Trường vector có giá trị <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1400"><span class="MJXp-mn" id="MJXp-Span-1401">0</span></span></span><script type="math/tex" id="MathJax-Element-161">0</script></span> tại cả cực đại và cực tiểu của hàm mật độ (trên dữ liệu đa tạp) ước lượng. Ví dụ, nhánh xoắn ốc tạo thành đa tạp <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1402"><span class="MJXp-mn" id="MJXp-Span-1403">1</span></span></span><script type="math/tex" id="MathJax-Element-162">1</script></span> chiều của các cực đại cục bộ được kết nối với nhau. Các cực tiểu cục bộ xuất hiện gần điểm chính giữa của khoảng cách giữa hai nhánh. Khi chuẩn (norm) của sai số tái thiết (thể hiện bằng độ dài của mũi tên) lớn, xác suất có thể tăng đáng kể bằng cách di chuyển hướng của mũi tên, và trường hợp đó đó chủ yếu là tại những nơi có xác suất thấp. Bộ tự mã hóa ánh xạ những điểm có xác suất thấp này tới nơi có xác suất tái thiết cao hơn. Ở nơi có xác suất là cực đại, mũi tên co lại vì sự tái thiết trở nên chính xác hơn. Hình ảnh này được tái hiện với sự cho phép từ Alain và Bengio (2013).</p>
</blockquote><p>// ------ Sơn Lâm kết thúc dịch ở đây p509 - p512</p><p>----- Nguyen Thanh Chinh bat dau dich tu day ----------------</p><h1 id="146-Học-đa-tạp-sử-dụng-bộ-tự-mã-hóa"><a class="anchor hidden-xs" href="#146-Học-đa-tạp-sử-dụng-bộ-tự-mã-hóa" title="146-Học-đa-tạp-sử-dụng-bộ-tự-mã-hóa"><span class="octicon octicon-link"></span></a>14.6 Học đa tạp sử dụng bộ tự mã hóa</h1><p>Giống như nhiều thuật toán học máy khác, các bộ tự mã hóa khai thác ý tưởng về việc dữ liệu tập trung quanh một hoặc một tập nhỏ các đa tạp có số chiều thấp, như đã được mô tả trong phần 5.11.3. Một số thuật toán học máy khác khai thác ý tưởng này chỉ khi chúng học một hàm hoạt động hiệu quả trong phạm vi đa tạp nhưng sẽ đưa ra các kết quả bất thường nếu đầu vào nằm ngoài đa tạp. Bộ tự mã hóa được phát triển từ ý tưởng này và nhắm tới mục tiêu học được cấu trúc của đa tạp.</p><p>Cần nhắc lại những đặc tính quan trọng của đa tạp để hiểu cách bộ tự mã hóa thực hiện mục tiêu này.</p><p>Một đặc tính quan trọng của đa tạp đó là <em>mặt phẳng tiếp tuyến</em> (tagent planes). Tại mỗi điểm <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1404"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1405">x</span></span></span><script type="math/tex" id="MathJax-Element-163">\boldsymbol x</script></span> trên một không gian đa tạp <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1406"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1407">d</span></span></span><script type="math/tex" id="MathJax-Element-164">d</script></span> chiều, mặt phẳng tiếp tuyến này được định nghĩa bởi <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1408"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1409">d</span></span></span><script type="math/tex" id="MathJax-Element-165">d</script></span> vector cở sở trải dài theo các hướng biến thiên cục bộ hợp lệ trên đa tạp. Như minh hoạ trong hình 14.6, các hướng cục bộ này chỉ định cách mà ta có thể thay đổi <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1410"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1411">x</span></span></span><script type="math/tex" id="MathJax-Element-166">\boldsymbol x</script></span> một lượng rất nhỏ ngay cả trong phạm vi đa tạp.</p><p>Mọi quá trình huấn luyện bộ tự mã hóa sẽ bao gồm việc đảm bảo cân bằng giữa hai ràng buộc sau:</p><ol>
<li>
<p>Học một biểu diễn <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1412"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1413">h</span></span></span><script type="math/tex" id="MathJax-Element-167">\boldsymbol {h}</script></span> của một ví dụ huấn luyện <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1414"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1415">x</span></span></span><script type="math/tex" id="MathJax-Element-168">\boldsymbol{x}</script></span> sao cho <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1416"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1417">x</span></span></span><script type="math/tex" id="MathJax-Element-169">\boldsymbol {x}</script></span> có thể được khôi phục tương đối từ <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1418"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1419">h</span></span></span><script type="math/tex" id="MathJax-Element-170">\boldsymbol {h}</script></span> thông qua bộ giải mã. Việc <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1420"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1421">x</span></span></span><script type="math/tex" id="MathJax-Element-171">\boldsymbol {x}</script></span> chỉ được chọn từ dữ liệu huấn luyện là rất quan trọng, bởi bộ tự mã hóa không cần phải có khả năng phục hồi tốt với các đầu vào không nằm trong phân phối sinh dữ liệu.</p>
</li>
<li>
<p>Đáp ứng điều kiện ràng buộc hoặc các mức phạt kiểm soát. Đó có thể là một ràng buộc về mặt kiến trúc để giới hạn dung lượng của bộ tự mã hóa, hoặc cũng có thể là số hạng kiểm soát được thêm vào hàm chi phí tái thiết. Những kỹ thuật này thường ưu tiên các giải pháp ít nhạy cảm với đầu vào hơn.</p>
</li>
</ol><p>Rõ ràng, mô hình sẽ không hữu dụng nếu vi phạm một trong hai ràng buộc trên, dù là sao chép hoàn toàn đầu vào tới đầu ra hay là bỏ qua đầu vào. Ta cần cân bằng giữa hai ràng buộc cùng lúc vì điều này buộc các biễu diễn ẩn nắm bắt tốt thông tin về phân phối sinh dữ liệu. Một nguyên tắc quan trọng đó là bộ tự mã hóa có thể chỉ biểu diễn <em>các biến thể cần thiết cho việc tái cấu trúc ví dụ huấn luyện</em>. Nếu phân phối sinh dữ liệu tập trung gần một đa tạp số chiều thấp, những biểu diễn được sinh ra sẽ ngầm nắm bắt một hệ toạ độ cục bộ cho đa tạp này: chỉ những biến thể của tiếp tuyến với đa tạp xung quanh <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1422"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1423">x</span></span></span><script type="math/tex" id="MathJax-Element-172">\boldsymbol x</script></span> là cần tương ứng với những thay đổi ở <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1424"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1425">h</span><span class="MJXp-mo" id="MJXp-Span-1426" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mrow" id="MJXp-Span-1427"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-1428">f</span></span><span class="MJXp-mo" id="MJXp-Span-1429" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1430">x</span><span class="MJXp-mo" id="MJXp-Span-1431" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-173">\boldsymbol h = \mathcal{f}(\boldsymbol x)</script></span>. Do đó, bộ mã hóa sẽ học một phép ánh xạ từ không gian đầu vào <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1432"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1433">x</span></span></span><script type="math/tex" id="MathJax-Element-174">\boldsymbol x</script></span> tới không gian biểu diễn, ánh xạ này chỉ nhạy cảm với những thay đổi dọc theo các hướng của đa tạp, và ít nhạy cảm hơn với các thay đổi theo hướng trực giao với đa tạp.</p><p><img src="https://i.imgur.com/BwEjKQA.png" alt=""></p><blockquote>
<p>Hình 14.6: Một minh hoạ cho khái niệm siêu phẳng tiếp tuyến. Chúng tôi tạo ra một đa tạp <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1434"><span class="MJXp-mn" id="MJXp-Span-1435">1</span></span></span><script type="math/tex" id="MathJax-Element-175">1</script></span> chiều trong không gian <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1436"><span class="MJXp-mn" id="MJXp-Span-1437">784</span></span></span><script type="math/tex" id="MathJax-Element-176">784</script></span> chiều. Lấy một ảnh trong bộ dữ liệu MNIST với <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1438"><span class="MJXp-mn" id="MJXp-Span-1439">784</span></span></span><script type="math/tex" id="MathJax-Element-177">784</script></span> điểm ảnh và biến đổi bức ảnh này bằng cách tịnh tiến nó theo chiều dọc. Số phép tịnh tiến như vậy xác định một toạ độ dọc theo đa tạp <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1440"><span class="MJXp-mn" id="MJXp-Span-1441">1</span></span></span><script type="math/tex" id="MathJax-Element-178">1</script></span> chiều, vạch ra một đường cong trong không gian ảnh. Đồ thị trên biểu diễn một vài điểm trong đa tạp. Để biểu diễn một cách trực quan, chúng tôi đã chiếu đa tạp vào không gian <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1442"><span class="MJXp-mn" id="MJXp-Span-1443">2</span></span></span><script type="math/tex" id="MathJax-Element-179">2</script></span> chiều bằng PCA. Một đa tạp <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1444"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1445">n</span></span></span><script type="math/tex" id="MathJax-Element-180">n</script></span> chiều luôn có một mặt phẳng tiếp tuyến <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1446"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1447">n</span></span></span><script type="math/tex" id="MathJax-Element-181">n</script></span> chiều tại mọi điểm. Mặt phẳng này tiếp xúc với bề mặt tại một điểm tiếp tuyến và có hướng song song với bề mặt tại điểm đó. Nó xác định không gian các hướng có thể di chuyển trong phạm vi đa tạp. Đa tạp <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1448"><span class="MJXp-mn" id="MJXp-Span-1449">1</span></span></span><script type="math/tex" id="MathJax-Element-182">1</script></span> chiều trên chỉ có một đường tiếp tuyến đơn. Chúng tôi minh hoạ ví dụ về một đường tiếp tuyến tại một điểm bằng một hình ảnh cho thấy cách hướng tiếp tuyến này xuất hiện trong không gian hình ảnh. Các điểm ảnh màu xám biểu thị các điểm ảnh không thay đổi khi ta di chuyển dọc theo đường tiếp tuyến này, điểm ảnh màu trắng biểu thị các điểm ảnh sẽ sáng lên, điểm ảnh màu đen cho thấy điểm ảnh sẽ tối đi.</p>
</blockquote><p>Một ví dụ khác về trường hợp <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1450"><span class="MJXp-mn" id="MJXp-Span-1451">1</span></span></span><script type="math/tex" id="MathJax-Element-183">1</script></span> chiều được minh hoạ ở hình 14.7, có thể thấy, bằng cách khiến cho hàm tái thiết ít nhạy cảm với nhiễu loạn xung quanh các điểm dữ liệu ở đầu vào, bộ tự mã hóa đã khôi phục được cấu trúc của đa tạp.</p><p>Để hiểu tại sao bộ tự mã hóa lại hữu ích đối với học đa tạp, cần phải so sánh nó với các hướng tiếp cận khác. Đặc tính cần học thông dụng nhất của đa tạp là một <em>biễu diễn</em> của các điểm dữ liệu nằm trong (hoặc gần) đa tạp đó. Một biểu diễn của một ví dụ huấn luyện cụ thể còn được gọi là <em>nhúng</em> của ví dụ đó, thường được biểu diễn bởi một vectơ có số chiều thấp, với kích thước nhỏ hơn không gian “xung quanh”. Một số thuật toán (các thuật toán học đa tạp phi tham số, sẽ được thảo luận bên dưới) trực tiếp học vector nhúng của mỗi ví dụ huấn luyện, trong khi các thuật toán khác học một phép ánh xạ tổng quát hơn, được gọi là bộ mã hóa, hoặc hàm biễu diễn, ánh xạ một điểm trong không gian xung quanh (không gian đầu vào) thành vector nhúng của nó.</p><p><img src="https://i.imgur.com/MAO70vk.png" alt=""></p><blockquote>
<p>Hình 14.7: Nếu một bộ tự mã hóa học một hàm tái cấu trúc bất biến trước những nhiễu loạn nhỏ xung quanh điểm dữ liệu, nó sẽ nắm bắt được cấu trúc đa tạp của dữ liệu. Đa tạp ở đây có cấu trúc là một tập hợp các đa tạp <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1452"><span class="MJXp-mn" id="MJXp-Span-1453">0</span></span></span><script type="math/tex" id="MathJax-Element-184">0</script></span> chiều. Đường chéo nét đứt biểu thị hàm mục tiêu tái thiết đồng nhất. Hàm tái thiết tối ưu giao với hàm đồng nhất khi gặp một điểm dữ liệu. Các mũi tên ngang nằm phía dưới đồ thị biểu thị hướng của vector tái cấu trúc <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1454"><span class="MJXp-mrow" id="MJXp-Span-1455"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-1456">r</span></span><span class="MJXp-mo" id="MJXp-Span-1457" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1458">x</span><span class="MJXp-mo" id="MJXp-Span-1459" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-1460" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1461">x</span></span></span><script type="math/tex" id="MathJax-Element-185">\mathcal{r}(\boldsymbol x) - \boldsymbol x</script></span> tại điểm xuất phát của mỗi mũi tên, trong không gian đầu vào, luôn trỏ về phía “đa tạp” gần nhất (một điểm dữ liệu trong không gian <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1462"><span class="MJXp-mn" id="MJXp-Span-1463">1</span></span></span><script type="math/tex" id="MathJax-Element-186">1</script></span> chiều). Bộ tự mã hóa khử nhiễu cố gắng khiến cho đạo hàm của hàm tái cấu trúc <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1464"><span class="MJXp-mrow" id="MJXp-Span-1465"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-1466">r</span></span><span class="MJXp-mo" id="MJXp-Span-1467" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1468">x</span><span class="MJXp-mo" id="MJXp-Span-1469" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-187">\mathcal{r}(\boldsymbol x)</script></span> là nhỏ xung quanh mỗi điểm dữ liệu. Bộ tự mã hóa chèn ép (contractive autoencoder) cũng thực hiện điều tương tự đối với bộ mã hóa. Đạo hàm của <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1470"><span class="MJXp-mrow" id="MJXp-Span-1471"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-1472">r</span></span><span class="MJXp-mo" id="MJXp-Span-1473" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1474">x</span><span class="MJXp-mo" id="MJXp-Span-1475" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-188">\mathcal{r}(\boldsymbol x)</script></span> phải là nhỏ xung quanh các điểm dữ liệu, nhưng nó có thể có giá trị lớn giữa các điểm dữ liệu với nhau. Không gian giữa các điểm dữ liệu tương ứng với vùng không gian giữa các đa tạp, nơi các hàm tái thiết phải có giá trị đạo hàm lớn để ánh xạ các điểm sai hỏng trở lại đa tạp.</p>
</blockquote><p><img src="https://i.imgur.com/jRZQy8W.png" alt=""></p><blockquote>
<p>Hình 14.8: Thuật toán học đa tạp phi tham số xây dựng một đồ thị lân cận gần nhất, trong đó, các nút đại diện cho các ví dụ huấn luyện và các cạnh có hướng chỉ ra mối liên hệ giữa các lân cận gần nhất. Do đó, nhiều thuật toán khác nhau có thể tìm được mặt phẳng tiếp tuyến tương ứng với một lân cận trong đồ thị cũng như một hệ toạ độ liên kết mỗi ví dụ huấn luyện với một vector vị trí có giá trị thực - còn gọi là vector nhúng. Một biễu diễn như vậy có thể được khái quát hóa thành một ví dụ huấn luyện mới bởi một dạng nội suy. Các phương pháp này sẽ hoạt động tốt, miễn sao số lượng ví dụ là đủ lớn để bao phủ độ cong và xoắn của đa tạp. Hình ảnh được lấy từ bộ dữ liệu ảnh mặt người theo nhiều hướng QMUL(Gong <em>et al</em>, 2000).</p>
</blockquote><p>Học đa tạp tập trung chủ yếu vào quá trình học không giám sát cố gắng nắm bắt cấu trúc của đa tạp đó. Phần lớn nghiên cứu ban đầu về học đa tạp phi tuyến tính tập trung vào các phương pháp phi tham số dựa trên <em>đồ thị lân cận gần nhất</em>. Mỗi nút trong đồ thị ứng với một ví dụ huấn luyện, trong khi các cạnh liên kết những điểm lân cận với nhau. Những phương pháp này (Schölkopfet <em>et al</em>, 1998; Roweis &amp; Saul, 2000; Tenenbaum <em>et al</em>, 2000; Brand, 2003; Belkinand Niyogi, 2003; Donoho &amp; Grimes, 2003; Weinberger &amp; Saul, 2004; Hintonand Roweis, 2003; van der Maaten &amp; Hinton, 2008) gán mỗi nút với một mặt phẳng tiếp tuyến mở rộng các hướng biến thiên ứng với các vector giữa ví dụ đó và lân cận của nó, như được minh hoạ trong hình 14.8.</p><p>Sau đó, ta có thể thu được một hệ toạ độ toàn cục thông qua một phép tối ưu hoặc giải một hệ tuyến tính. Hình 14.9 minh hoạ cách một đa tạp có thể được <em>lát</em> (tiled) bởi số lượng lớn miếng vá (hay còn được gọi là “bánh kếp”) dạng Gauss tuyến tính cục bộ (vì mô hình Gauss là phẳng theo các hướng tiếp tuyến).</p><p><img src="https://i.imgur.com/qtl5cBf.png" alt=""></p><blockquote>
<p>Hình 14.9: Nếu đã xác định được các mặt phẳng tiếp tuyến (xem hình 14.6) tại mỗi điểm, chúng có thể được bao phủ (lát) để tạo thành một hệ toạ độ toàn cục hay một hàm mật độ. Mỗi miếng vá cục bộ có thể được xem như một hệ toạ độ Euclidean cục bộ hoặc một miếng Gauss phẳng cục bộ - hay “bánh kếp” (pancake) - với một phương sai rất nhỏ theo các hương trực giao với mặt miếng bánh này và một phương sai rất lớn theo các hướng cấu thành hệ toạ độ trên miếng bánh. Một hỗn hợp các miếng Gauss này có thể cho ta một ước lượng về hàm mật độ, giống như trong thuật toán cửa sổ Pazen đa tạp hoặc như trong biến thể phi cục bộ dựa trên mạng neuron của nó (Bengio <em>et al</em>, 2006c).</p>
</blockquote><p>Một khó khăn cơ bản trong bài toán học đa tạp đối với các phương pháp cục bộ phi tham số nói trên đã được Bengio và Monperrus (2005) chỉ ra: Nếu đa tạp không quá mịn (có nhiều chóp, rãnh và xoắn), ta cần một số lượng ví dụ huấn luyện rất lớn để bao phủ trọn vẹn các vùng biến thiên này, và ta không có khả năng khái quát hóa các vùng biến thiên không được bao phủ bởi dữ liệu huấn luyện. Thật vậy, các phương pháp này chỉ có thể khái quát hình dạng của đa tạp thông qua phép nội suy giữa các điểm lân cận. Không may là đa tạp trong các tác vụ AI là rất khó để nắm bắt chỉ bằng ý tưởng nội suy cục bộ. Bạn có thể xem xét ví dụ về một đa tạp là kết quả từ sự dịch chuyển trong hình 14.6. Nếu quan sát chỉ một toạ độ trong vector đầu vào, <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1476"><span class="MJXp-msubsup" id="MJXp-Span-1477"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1478" style="margin-right: 0.05em;">x</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-1479" style="vertical-align: -0.4em;">i</span></span></span></span><script type="math/tex" id="MathJax-Element-189">x_i</script></span>, khi ảnh bị dịch đi, có thể thấy toạ độ đó cực đại hoặc cực tiểu mỗi khi điểm ảnh tương ứng với toạ độ này là sáng nhất hoặc tối nhất. Nói cách khác, độ phức tạp về các mẫu độ sáng trong các điểm ảnh ảnh hưởng lên độ phức tạp của đa tạp được tạo thành từ các phép biến đổi hình ảnh đơn giản. Điều này đã thúc đẩy việc sử dụng các biển diễn phân tán và các phương pháp học sâu để nắm bắt cấu trúc của đa tạp.</p><h1 id="147-Bộ-tự-mã-hóa-chèn-ép"><a class="anchor hidden-xs" href="#147-Bộ-tự-mã-hóa-chèn-ép" title="147-Bộ-tự-mã-hóa-chèn-ép"><span class="octicon octicon-link"></span></a>14.7 Bộ tự mã hóa chèn ép</h1><p>Bộ tự mã hóa chèn ép (Rifai <em>et al</em>, 2011a,b) thêm một đại lượng kiểm soát tường minh đối với đoạn mã <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1480"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1481">h</span><span class="MJXp-mo" id="MJXp-Span-1482" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mrow" id="MJXp-Span-1483"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-1484">f</span></span><span class="MJXp-mo" id="MJXp-Span-1485" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1486">x</span><span class="MJXp-mo" id="MJXp-Span-1487" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-190">\boldsymbol h = \mathcal{f}(\boldsymbol x)</script></span>, nhằm mục đích làm cho đạo hàm của <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1488"><span class="MJXp-mrow" id="MJXp-Span-1489"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-1490">f</span></span></span></span><script type="math/tex" id="MathJax-Element-191">\mathcal{f}</script></span> càng nhỏ càng tốt:<br>
<span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-1491"><span class="MJXp-mtable" id="MJXp-Span-1492"><span><span class="MJXp-mlabeledtr" id="MJXp-Span-1493" style="vertical-align: baseline;"><span class="MJXp-mtd" id="MJXp-Span-1494" style="text-align: center;"><span class="MJXp-mi" id="MJXp-Span-1495">Ω</span><span class="MJXp-mo" id="MJXp-Span-1496" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1497">h</span><span class="MJXp-mo" id="MJXp-Span-1498" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-1499" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1500">λ</span><span class="MJXp-msubsup" id="MJXp-Span-1501"><span class="MJXp-mrow" id="MJXp-Span-1502" style="margin-right: 0.05em;"><span class="MJXp-mo" id="MJXp-Span-1503" style="margin-left: 0em; margin-right: 0em;">‖</span><span class="MJXp-mfrac" id="MJXp-Span-1504" style="vertical-align: 0.25em;"><span class="MJXp-box"><span class="MJXp-mi" id="MJXp-Span-1505">∂</span><span class="MJXp-mrow" id="MJXp-Span-1506"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-1507">f</span></span><span class="MJXp-mo" id="MJXp-Span-1508" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1509">x</span><span class="MJXp-mo" id="MJXp-Span-1510" style="margin-left: 0em; margin-right: 0em;">)</span></span><span class="MJXp-box" style="margin-top: -0.9em;"><span class="MJXp-denom"><span><span class="MJXp-rule" style="height: 1em; border-top: none; border-bottom: 1px solid; margin: 0.1em 0px;"></span></span><span><span class="MJXp-box"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1511">x</span></span></span></span></span></span><span class="MJXp-mo" id="MJXp-Span-1512" style="margin-left: 0em; margin-right: 0em;">‖</span></span><span class="MJXp-script-box" style="height: 3.36em; vertical-align: -1.44em;"><span class="MJXp-script"><span><span style="margin-bottom: -0.25em;"><span class="MJXp-mn" id="MJXp-Span-1514">2</span></span></span></span><span class="MJXp-script"><span><span style="margin-top: -0.85em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1513">F</span></span></span></span></span></span><span class="MJXp-mo" id="MJXp-Span-1515" style="margin-left: 0em; margin-right: 0.222em;">.</span></span></span></span></span></span></span><script type="math/tex; mode=display" id="MathJax-Element-192">\Omega (\boldsymbol h) = \lambda \left \| \frac{\partial \mathcal{f}(\boldsymbol x)}{x} \right \|^2_F .
\tag{14.18}</script></span></p><p>Mức phạt <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1516"><span class="MJXp-mi" id="MJXp-Span-1517">Ω</span><span class="MJXp-mo" id="MJXp-Span-1518" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1519">h</span><span class="MJXp-mo" id="MJXp-Span-1520" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-193">\Omega (h)</script></span> là chuẩn Frobenius bình phương (tổng bình phương của các phần tử) của ma trận Jacobi của các đạo hàm từng phần ứng với hàm mã hóa.</p><p>Có một sự liên kết giữa bộ tự mã hóa khử nhiễu và bộ tự mã hóa chèn ép, Alain và Bengio (2013) đã chỉ ra rằng, trong giới hạn một lượng nhiễu nhỏ tuân theo phân phối Gauss, sai số tái thiết khử nhiễu tương đương với mức phạt chèn ép trong hàm tái thiết của ánh xạ từ <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1521"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1522">x</span></span></span><script type="math/tex" id="MathJax-Element-194">\boldsymbol x</script></span> đến <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1523"><span class="MJXp-mrow" id="MJXp-Span-1524"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-1525">r</span></span><span class="MJXp-mo" id="MJXp-Span-1526" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mrow" id="MJXp-Span-1527"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-1528">g</span></span><span class="MJXp-mo" id="MJXp-Span-1529" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mrow" id="MJXp-Span-1530"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-1531">f</span></span><span class="MJXp-mo" id="MJXp-Span-1532" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1533">x</span><span class="MJXp-mo" id="MJXp-Span-1534" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-1535" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-195">\mathcal{r} = \mathcal{g}(\mathcal{f}(\boldsymbol x))</script></span>. Nói cách khác, bộ tự mã hóa khử nhiễu kháng các nhiễu nhỏ ở đầu vào thông qua hàm tái thiết, trong khi bộ tự mã hóa chèn ép kháng các nhiễu nhỏ ở đầu vào thông qua hàm trích chọn đặc trưng (<em>ND: có lẽ ý tác giả ở đây là hàm mã hóa <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1536"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1537">f</span></span></span><script type="math/tex" id="MathJax-Element-196">f</script></span>, hai hàm này là hai phân đoạn cấu tạo nên bộ tự mã hóa</em>). Khi sử dụng mức phạt chèn ép dựa trên ma trận Jacobi để tiền huấn luyện những đặc trưng <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1538"><span class="MJXp-mrow" id="MJXp-Span-1539"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-1540">f</span></span><span class="MJXp-mo" id="MJXp-Span-1541" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1542">x</span><span class="MJXp-mo" id="MJXp-Span-1543" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-197">\mathcal{f}(\boldsymbol x)</script></span> dùng cho một bộ phân loại, kết quả phân loại chính xác nhất thường đạt được khi áp dụng mức phạt với <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1544"><span class="MJXp-mrow" id="MJXp-Span-1545"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-1546">f</span></span><span class="MJXp-mo" id="MJXp-Span-1547" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1548">x</span><span class="MJXp-mo" id="MJXp-Span-1549" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-198">\mathcal{f}(\boldsymbol x)</script></span> thay vì với <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1550"><span class="MJXp-mrow" id="MJXp-Span-1551"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-1552">g</span></span><span class="MJXp-mo" id="MJXp-Span-1553" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mrow" id="MJXp-Span-1554"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-1555">f</span></span><span class="MJXp-mo" id="MJXp-Span-1556" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1557">x</span><span class="MJXp-mo" id="MJXp-Span-1558" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-1559" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-199">\mathcal{g}(\mathcal{f}(\boldsymbol x))</script></span>. Mức phạt chèn ép đối với <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1560"><span class="MJXp-mrow" id="MJXp-Span-1561"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-1562">f</span></span><span class="MJXp-mo" id="MJXp-Span-1563" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1564">x</span><span class="MJXp-mo" id="MJXp-Span-1565" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-200">\mathcal{f}(\boldsymbol x)</script></span> cũng liên quan mật thiết với thuật toán so sánh điểm số đã được thảo luận trong mục 14.5.1.</p><p>-----Nguyen Thi Ngoc Anh bat dau dich tu day (p519-523)----<br>
Cái tên <em>chèn ép</em> phát sinh từ cách mà CAE làm cong (warp) không gian. Đặc biệt, bởi vì CAE được huấn luyện để kháng nhiễu ở đầu vào của nó, nó được khuyến khích ánh xạ một lân cận của các điểm đầu vào đến một lân cận nhỏ hơn của các điểm đầu ra. Hay ta có thể nói rằng nó chèn ép vùng lân cận đầu vào để có vùng lân cận đầu ra nhỏ hơn.</p><p>Cụ thể hơn, mô hình CAE chỉ thể hiện tính chèn ép trong phạm vi cục bộ — toàn bộ nhiễu của một điểm huấn luyện được ánh xạ đến gần với <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1566"><span class="MJXp-mrow" id="MJXp-Span-1567"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-1568">f</span></span><span class="MJXp-mo" id="MJXp-Span-1569" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1570">x</span><span class="MJXp-mo" id="MJXp-Span-1571" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-201">\mathcal{f}(\boldsymbol x)</script></span>. Về tổng thể, hai điểm phân biệt <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1572"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1573">x</span></span></span><script type="math/tex" id="MathJax-Element-202">\boldsymbol x</script></span> và <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1574"><span class="MJXp-msup" id="MJXp-Span-1575"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1576" style="margin-right: 0.05em;">x</span><span class="MJXp-mo MJXp-script" id="MJXp-Span-1577" style="vertical-align: 0.5em;">′</span></span></span></span><script type="math/tex" id="MathJax-Element-203">\boldsymbol x'</script></span> có thể được ánh xạ tới các điểm <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1578"><span class="MJXp-mrow" id="MJXp-Span-1579"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-1580">f</span></span><span class="MJXp-mo" id="MJXp-Span-1581" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1582">x</span><span class="MJXp-mo" id="MJXp-Span-1583" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-204">\mathcal{f}(\boldsymbol x)</script></span> và <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1584"><span class="MJXp-mrow" id="MJXp-Span-1585"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-1586">f</span></span><span class="MJXp-mo" id="MJXp-Span-1587" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-msup" id="MJXp-Span-1588"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1589" style="margin-right: 0.05em;">x</span><span class="MJXp-mo MJXp-script" id="MJXp-Span-1590" style="vertical-align: 0.5em;">′</span></span><span class="MJXp-mo" id="MJXp-Span-1591" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-205">\mathcal{f}(\boldsymbol x')</script></span> nằm cách xa nhau hơn hai điểm ban đầu. Sẽ hợp lý hơn nếu hàm <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1592"><span class="MJXp-mrow" id="MJXp-Span-1593"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-1594">f</span></span></span></span><script type="math/tex" id="MathJax-Element-206">\mathcal{f}</script></span> có thể mở rộng ở khoảng giữa hoặc cách xa các đa tạp dữ liệu (tham khảo tình huống xảy ra trong ví dụ hình 14.7). Khi mức phạt <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1595"><span class="MJXp-mi" id="MJXp-Span-1596">Ω</span><span class="MJXp-mo" id="MJXp-Span-1597" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1598">h</span><span class="MJXp-mo" id="MJXp-Span-1599" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-207">\Omega (\boldsymbol h)</script></span> được áp dụng cho các đơn vị hình chữ S, một cách đơn giản để co nhỏ ma trận Jacobian là làm cho các đơn vị hình chữ S chụm lại ở giá trị <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1600"><span class="MJXp-mn" id="MJXp-Span-1601">0</span></span></span><script type="math/tex" id="MathJax-Element-208">0</script></span> hoặc <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1602"><span class="MJXp-mn" id="MJXp-Span-1603">1</span></span></span><script type="math/tex" id="MathJax-Element-209">1</script></span>. Điều này khiến CAE có xu hướng mã hóa các điểm đầu vào với giá trị ở cực (<em>ND: giá trị cực đại hoặc cực tiểu - extreme values</em>) của hàm chữ S này là một mã nhị phân. Điều này cũng đảm bảo rằng CAE sẽ trải rộng các giá trị mã của nó trong suốt hầu hết các hình siêu lập phương mà các đơn vị ẩn hình chữ S của nó có thể mở rộng ra.</p><p>Chúng ta có thể coi ma trận Jacobian <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1604"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1605">J</span></span></span><script type="math/tex" id="MathJax-Element-210">J</script></span> tại điểm <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1606"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1607">x</span></span></span><script type="math/tex" id="MathJax-Element-211">\boldsymbol x</script></span> là một phép xấp xỉ hàm mã hóa phi tuyến <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1608"><span class="MJXp-mrow" id="MJXp-Span-1609"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-1610">f</span></span><span class="MJXp-mo" id="MJXp-Span-1611" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1612">x</span><span class="MJXp-mo" id="MJXp-Span-1613" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-212">\mathcal{f}(\boldsymbol x)</script></span> như một toán tử tuyến tính. Điều này cho phép ta sử dụng từ “chèn ép” có cơ sở hơn. Theo lý thuyết về toán tử tuyến tính, toán tử tuyến tính được xem là bị chèn ép nếu định mức <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1614"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1615">J</span><span class="MJXp-mrow" id="MJXp-Span-1616"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1617">x</span></span></span></span><script type="math/tex" id="MathJax-Element-213">J{\boldsymbol x}</script></span> vẫn nhỏ hơn hoặc bằng 1 đối với tất cả các đơn vị tiêu chuẩn <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1618"><span class="MJXp-mrow" id="MJXp-Span-1619"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1620">x</span></span></span></span><script type="math/tex" id="MathJax-Element-214">{\boldsymbol x}</script></span>. Nói cách khác, <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1621"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1622">J</span></span></span><script type="math/tex" id="MathJax-Element-215">J</script></span> có tính chèn ép nếu ảnh của quả cầu đơn vị của nó hoàn toàn được bao lại bởi quả cầu đơn vị. Chúng ta có thể nghĩ về CAE như là mức phạt chuẩn Frobenius của xấp xỉ tuyến tính cục bộ của <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1623"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1624">f</span><span class="MJXp-mo" id="MJXp-Span-1625" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1626">x</span><span class="MJXp-mo" id="MJXp-Span-1627" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-216">f(\boldsymbol x)</script></span> tại mọi điểm huấn luyện <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1628"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1629">x</span></span></span><script type="math/tex" id="MathJax-Element-217">\boldsymbol x</script></span> nhằm khuyến khích mỗi toán tử tuyến tính cục bộ này trở thành một phép co hẹp.</p><p>Như đã được giới thiệu trong phần 14.6, các bộ tự mã hóa có kiểm soát học các đa tạp theo cách cân bằng hai lực đối ngẫu. Trong trường hợp của CAE, hai lực này là lỗi tái thiết và hình phạt chèn ép <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1630"><span class="MJXp-mi" id="MJXp-Span-1631">Ω</span><span class="MJXp-mo" id="MJXp-Span-1632" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1633">h</span><span class="MJXp-mo" id="MJXp-Span-1634" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-218">\Omega(\boldsymbol {h})</script></span>. Lỗi tái thiết đứng độc lập sẽ khuyến khích CAE học một hàm đồng nhất. Trong khi chi riêng hình phạt co sẽ khuyến khích CAE học các đặc trưng cố định đối với bất kì sự thay đổi nào của <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1635"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1636">x</span></span></span><script type="math/tex" id="MathJax-Element-219">\boldsymbol x</script></span>. Sự thỏa hiệp giữa hai lực này tạo ra một bộ tự mã hóa có các giá trị dẫn xuất <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1637"><span class="MJXp-mfrac" id="MJXp-Span-1638" style="vertical-align: 0.25em;"><span class="MJXp-box MJXp-script"><span class="MJXp-mi" id="MJXp-Span-1639">∂</span><span class="MJXp-mrow" id="MJXp-Span-1640"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-1641">f</span></span><span class="MJXp-mo" id="MJXp-Span-1642">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1643">x</span><span class="MJXp-mo" id="MJXp-Span-1644">)</span></span><span class="MJXp-box" style="margin-top: -0.9em;"><span class="MJXp-denom"><span><span class="MJXp-rule" style="height: 1em; border-top: none; border-bottom: 1px solid; margin: 0.1em 0px;"></span></span><span><span class="MJXp-box MJXp-script"><span class="MJXp-mi" id="MJXp-Span-1645">∂</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1646">x</span></span></span></span></span></span></span></span><script type="math/tex" id="MathJax-Element-220">\frac{\partial \mathcal{f}( \boldsymbol {x})}{\partial \boldsymbol{x}}</script></span> hầu như là nhỏ. Chỉ một số lượng nhỏ các đơn vị ẩn, ứng với một số lượng nhỏ các hướng của đầu vào, có thể có các giá trị dẫn xuất đáng kể.</p><p>Mục đích của CAE là học cấu trúc đa tạp của dữ liệu. Các hướng <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1647"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1648">x</span></span></span><script type="math/tex" id="MathJax-Element-221">\boldsymbol {x}</script></span> với <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1649"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1650">J</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1651">x</span></span></span><script type="math/tex" id="MathJax-Element-222">J \boldsymbol {x}</script></span> lớn thay đổi <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1652"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1653">h</span></span></span><script type="math/tex" id="MathJax-Element-223">\boldsymbol {h}</script></span> nhanh chóng, vì vậy đây có thể là hướng xấp xỉ các mặt phẳng tiếp tuyến của đa tạp này. Thí nghiệm của Rifai et al. (2011a, b) chỉ ra rằng việc huấn luyện CAE dẫn đến hầu hết các giá trị suy biến của <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1654"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1655">J</span></span></span><script type="math/tex" id="MathJax-Element-224">J</script></span> giảm xuống dưới 1 về độ lớn và do đó trở nên bị chèn ép. Tuy nhiên, một số ít giá trị suy biến vẫn ở trên mức 1, vì mức phạt lỗi tái thiết khuyến khích CAE mã hóa các hướng với phương sai cục bộ lớn nhất. Các hướng tương ứng với các giá trị suy biến lớn nhất được lý giải là các hướng tiếp tuyến mà bộ tự mã hóa chèn ép đã học được. Một cách lý tưởng, các hướng tiếp tuyến này phải tương ứng với các biến thể thực trong dữ liệu. Ví dụ: một CAE áp dụng cho các hình ảnh nên học các vector tiếp tuyến chỉ ra hình ảnh thay đổi như thế nào khi các vật thể trong hình ảnh dần dần thay đổi tư thế, như trong hình 14.6. Các hình ảnh của các vectơ suy biến thu được bằng thực nghiệm có vẻ tương ứng với các biến đổi có ý nghĩa của hình ảnh đầu vào, như trong hình 14.10 dưới đây.</p><p><img src="https://i.imgur.com/a1J86s9.png" alt=""></p><p>Hình 14.10: Minh họa vectơ tiếp tuyến của đa tạp được ước lượng bởi PCA cục bộ và bởi một bộ tự mã hóa chèn ép . Vị trí trong đa tạp này được định nghĩa bởi đầu vào ảnh của một chú chó lấy từ tập dữ liệu CIFAR-10. Các vectơ tiếp tuyến được ước tính bởi các vectơ suy biến chỉ dẫn của ma trận Jacobian <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1656"><span class="MJXp-mfrac" id="MJXp-Span-1657" style="vertical-align: 0.25em;"><span class="MJXp-box MJXp-script"><span class="MJXp-mi" id="MJXp-Span-1658">∂</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1659">h</span></span><span class="MJXp-box" style="margin-top: -0.9em;"><span class="MJXp-denom"><span><span class="MJXp-rule" style="height: 1em; border-top: none; border-bottom: 1px solid; margin: 0.1em 0px;"></span></span><span><span class="MJXp-box MJXp-script"><span class="MJXp-mi" id="MJXp-Span-1660">∂</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1661">x</span></span></span></span></span></span></span></span><script type="math/tex" id="MathJax-Element-225">\frac { \partial \boldsymbol { h } } { \partial \boldsymbol { x } }</script></span> của ánh xạ từ đầu vào đến đoạn mã. Mặc dù cả PCA cụ bộ lẫn CAE đều có thể bắt được các tiếp tuyến cục bộ nhưng CAE có thể hình thành các ước tính chính xác hơn từ nguồn dữ liệu huấn luyện có giới hạn bởi vì nó khai thác thông số chia sẻ trên các vị trí khác nhau, các vị trí này chia sẻ một tập con các đơn vị ẩn đang hoạt động. Các hướng tiếp tuyến CAE thông thường tuân theo các bộ phận chuyển động hoặc thay đổi của vật thể (chẳng hạn như đầu hoặc chân). Các hình ảnh được sao chép với sự cho phép của Rifai và cộng sự (2011c).</p><p>Một vấn đề thực tế với tiêu chí kiểm soát CAE là mặc dù chi phí tính toán của nó thấp trong trường hợp là một bộ tự mã hóa với chỉ duy nhất một lớp ẩn, sẽ trở nên tốn kém hơn nhiều trong trường hợp các bộ tự mã hóa có nhiều tầng. Chiến lược tiếp theo được đưa ra bởi Rifai cùng cộng sự (2011a) là huấn luyện riêng một loạt các bộ tự động mã động một tầng, mỗi tầng được huấn luyện để tái tạo tầng ẩn của bộ tự mã hóa trước đó. Sự kết hợp các phần của các bộ tự động mã này lại sẽ tạo thành một bộ tự mã hóa đa tầng. Bởi vì mỗi tầng được huấn luyện riêng biệt để chèn ép theo phạm vi cục bộ, bộ tự mã hóa đa tầng này vẫn giữ nguyên tính chèn ép như các thành phần của nó. Kết quả này không giống như kết quả thu được bằng cách huấn luyện chung toàn bộ kiến trúc với một hình phạt trên Jacobian trên một bộ đa tầng, nhưng cách này lại bắt được nhiều đặc tính định tính mong muốn.</p><p>Một vấn đề thực tế khác là mức phạt chèn ép sẽ vô giá trị nếu chúng ta không áp đặt một số phép biến đổi có tỷ lệ lên bộ giải mã. Ví dụ: bộ mã hóa có thể thực hiện phép nhân đầu vào với một hằng số nhỏ <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1662"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1663">ϵ</span></span></span><script type="math/tex" id="MathJax-Element-226">\epsilon</script></span>, bộ giải mã có thể thực hiện phép chia đoạn mã cho <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1664"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1665">ϵ</span></span></span><script type="math/tex" id="MathJax-Element-227">\epsilon</script></span> này. Khi <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1666"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1667">ϵ</span></span></span><script type="math/tex" id="MathJax-Element-228">\epsilon</script></span> tiến đến 0, phần mã hóa sẽ điều khiển mức phạt chèn ép <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1668"><span class="MJXp-mi" id="MJXp-Span-1669">Ω</span><span class="MJXp-mo" id="MJXp-Span-1670" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1671">h</span><span class="MJXp-mo" id="MJXp-Span-1672" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-229">\Omega ( \boldsymbol { h } )</script></span> tiến đến 0 mà không học gì về phân phối. Trong khi đó, bộ giải mã duy trì việc tái thiết một cách hoàn hảo. Theo Rifaiet cùng cộng sự (2011a), điều này có thể được ngăn chặn bằng cách cố định các trọng số của  <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1673"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1674">f</span></span></span><script type="math/tex" id="MathJax-Element-230">f</script></span> và <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1675"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1676">g</span></span></span><script type="math/tex" id="MathJax-Element-231">g</script></span>. Cả <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1677"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1678">f</span></span></span><script type="math/tex" id="MathJax-Element-232">f</script></span> và <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1679"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1680">g</span></span></span><script type="math/tex" id="MathJax-Element-233">g</script></span> là các tầng mạng neutral chuẩn bao gồm một phép biến đổi ánh xạ affine theo sau là một phép biến đổi phi tuyến theo từng phần tử, vì vậy rất đơn giản để thiết lập ma trận trọng số của <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1681"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1682">g</span></span></span><script type="math/tex" id="MathJax-Element-234">g</script></span> là chuyển vị của ma trận trọng số của <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1683"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1684">f</span></span></span><script type="math/tex" id="MathJax-Element-235">f</script></span>.</p><h1 id="148-Phân-rã-thưa-tiên-đoán"><a class="anchor hidden-xs" href="#148-Phân-rã-thưa-tiên-đoán" title="148-Phân-rã-thưa-tiên-đoán"><span class="octicon octicon-link"></span></a>14.8. Phân rã thưa tiên đoán</h1><p><em>Phân rã thưa tiên đoán</em> (Predictive Sparse Decomposition - PSD) là một mô hình lai giữa phép mã hóa thưa và bộ tự mã hóa có tham số (Kavukcuoglu <em>et al</em>, 2008). Bộ mã hóa có tham số được huấn luyện để tiên đoán đầu ra của hệ quả lặp lại. PSD đã được áp dụng trong lĩnh vực học đặc trung không giám sát để nhận dạng đối tượng bằng hình ảnh và video<br>
(Kavukcuoglu <em>et al</em>, 2009, 2010; Jarrett <em>et al</em>, 2009; Farabet <em>et al</em>, 2011), cũng như âm thanh (Hena <em>et al</em>, 2011). Mô hình này bao gồm một bộ mã hóa <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1685"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1686">f</span><span class="MJXp-mo" id="MJXp-Span-1687" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1688">x</span><span class="MJXp-mo" id="MJXp-Span-1689" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-236">f(\boldsymbol x)</script></span> và một bộ giải mã <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1690"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1691">g</span><span class="MJXp-mo" id="MJXp-Span-1692" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1693">h</span><span class="MJXp-mo" id="MJXp-Span-1694" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-237">g(\boldsymbol h)</script></span>, cả hai bộ đều mang tính có tham số. Trong quá trình huấn luyện, <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1695"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1696">h</span></span></span><script type="math/tex" id="MathJax-Element-238">\boldsymbol {h}</script></span> được điều khiển bởi thuật toán tối ưu hóa. Qúa trình huấn luyện được thực hiện bằng cách cực tiểu hóa giá trị<br>
<span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-1697"><span class="MJXp-mtable" id="MJXp-Span-1698"><span><span class="MJXp-mlabeledtr" id="MJXp-Span-1699" style="vertical-align: baseline;"><span class="MJXp-mtd" id="MJXp-Span-1700" style="text-align: center;"><span class="MJXp-mo" id="MJXp-Span-1701" style="margin-left: 0em; margin-right: 0em;">‖</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1702">x</span><span class="MJXp-mo" id="MJXp-Span-1703" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-mrow" id="MJXp-Span-1704"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-1705">g</span></span><span class="MJXp-mo" id="MJXp-Span-1706" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1707">h</span><span class="MJXp-mo" id="MJXp-Span-1708" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-msubsup" id="MJXp-Span-1709"><span class="MJXp-mo" id="MJXp-Span-1710" style="margin-left: 0em; margin-right: 0.05em;">‖</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-1711" style="vertical-align: 0.5em;"><span class="MJXp-mn" id="MJXp-Span-1712">2</span></span></span><span class="MJXp-mo" id="MJXp-Span-1713" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1714">λ</span><span class="MJXp-mrow" id="MJXp-Span-1715"><span class="MJXp-mo" id="MJXp-Span-1716" style="margin-left: 0.167em; margin-right: 0.167em;">|</span></span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1717">h</span><span class="MJXp-msubsup" id="MJXp-Span-1718"><span class="MJXp-mrow" id="MJXp-Span-1719" style="margin-right: 0.05em;"><span class="MJXp-mo" id="MJXp-Span-1720" style="margin-left: 0.167em; margin-right: 0.167em;">|</span></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-1721" style="vertical-align: -0.4em;"><span class="MJXp-mn" id="MJXp-Span-1722">1</span></span></span><span class="MJXp-mo" id="MJXp-Span-1723" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1724">γ</span><span class="MJXp-mo" id="MJXp-Span-1725" style="margin-left: 0em; margin-right: 0em;">‖</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1726">h</span><span class="MJXp-mo" id="MJXp-Span-1727" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-mrow" id="MJXp-Span-1728"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-1729">f</span></span><span class="MJXp-mo" id="MJXp-Span-1730" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1731">x</span><span class="MJXp-mo" id="MJXp-Span-1732" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-msubsup" id="MJXp-Span-1733"><span class="MJXp-mo" id="MJXp-Span-1734" style="margin-left: 0em; margin-right: 0.05em;">‖</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-1735" style="vertical-align: 0.5em;"><span class="MJXp-mn" id="MJXp-Span-1736">2</span></span></span></span></span></span></span></span></span><script type="math/tex; mode=display" id="MathJax-Element-239"> \| \boldsymbol { x } - \mathcal {g} ( \boldsymbol { h } ) \| ^ { 2 } + \lambda | \boldsymbol { h } | _ { 1 } + \gamma \| \boldsymbol { h } - \mathcal {f} ( \boldsymbol { x } ) \| ^ { 2 }
\tag{14.19}</script></span><br>
Tương tự như mã hóa thưa, thuật toán huấn luyện liên tục thay đổi giữa cực tiểu hóa đoạn mã <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1737"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1738">h</span></span></span><script type="math/tex" id="MathJax-Element-240">\boldsymbol {h}</script></span> và cực tiểu hóa các tham số mô hình. Cực tiểu hóa ứng với <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1739"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1740">h</span></span></span><script type="math/tex" id="MathJax-Element-241">\boldsymbol {h}</script></span> diễn ra nhanh vì <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1741"><span class="MJXp-mrow" id="MJXp-Span-1742"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-1743">f</span></span><span class="MJXp-mo" id="MJXp-Span-1744" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1745">x</span><span class="MJXp-mo" id="MJXp-Span-1746" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-242">\mathcal{f}(\boldsymbol {x})</script></span> tạo ra giá trị khởi tạo tốt cho <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1747"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1748">h</span></span></span><script type="math/tex" id="MathJax-Element-243">\boldsymbol {h}</script></span>, và hàm chi phí ràng buộc <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1749"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1750">h</span></span></span><script type="math/tex" id="MathJax-Element-244">\boldsymbol {h}</script></span> có giá trị gần với <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1751"><span class="MJXp-mrow" id="MJXp-Span-1752"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-1753">f</span></span><span class="MJXp-mo" id="MJXp-Span-1754" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1755">x</span><span class="MJXp-mo" id="MJXp-Span-1756" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-245">\mathcal{f}(\boldsymbol {x})</script></span> bằng mọi giá. Phép trượt gradient đơn giản có thể thu được các giá trị hợp lý của <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1757"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1758">h</span></span></span><script type="math/tex" id="MathJax-Element-246">\boldsymbol h</script></span> chỉ trong mười bước trượt.</p><p>Quá trình huấn luyện được sử dụng bởi PSD khác so với quá trình huấn luyện đầu tiên một mô hình mã thưa, sau đó huấn luyện <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1759"><span class="MJXp-mrow" id="MJXp-Span-1760"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-1761">f</span></span><span class="MJXp-mo" id="MJXp-Span-1762" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1763">x</span><span class="MJXp-mo" id="MJXp-Span-1764" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-247">\mathcal{f}(\boldsymbol {x})</script></span> để dự đoán các giá trị của các đặc trưng được mã hóa thưa. Qúa trình huấn luyện PSD này ràng buộc phần giải mã sử dụng các tham số để hàm <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1765"><span class="MJXp-mrow" id="MJXp-Span-1766"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-1767">f</span></span><span class="MJXp-mo" id="MJXp-Span-1768" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1769">x</span><span class="MJXp-mo" id="MJXp-Span-1770" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-248">\mathcal{f}(\boldsymbol {x})</script></span> có thể suy ra những giá trị mã phù hợp.</p><p>Mã thưa có thể dự đoán được là một ví dụ về một suy luận gần đúng có thể học. Trong phần 19.5, chủ đề này sẽ được trình bày cụ thể hơn. Các công cụ được trình bày trong chương 19 sẽ nói cụ thể việc PSD có thể được giải thích như việc huấn luyện một mô hình xác suất mã thưa trực tiếp bằng cách tối đa hóa giới hạn dưới trên hàm hợp lý logarit của mô hình.</p><p>Trong các ứng dụng thực tế của PSD, sự tối ưu hóa lặp lại chỉ được sử dụng trong thời gian huấn luyện. Bộ mã hóa có tham số <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1771"><span class="MJXp-mrow" id="MJXp-Span-1772"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-1773">f</span></span></span></span><script type="math/tex" id="MathJax-Element-249">\mathcal{f}</script></span> được sử dụng để tính toán các đặc trưng được học khi mô hình được triển khai. Định tính (evaluating) <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1774"><span class="MJXp-mrow" id="MJXp-Span-1775"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-1776">f</span></span></span></span><script type="math/tex" id="MathJax-Element-250">\mathcal{f}</script></span> có chi phí tính toán nhỏ hơn so với suy luận <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1777"><span class="MJXp-mi MJXp-bold MJXp-italic" id="MJXp-Span-1778">h</span></span></span><script type="math/tex" id="MathJax-Element-251">\boldsymbol h</script></span> thông qua trượt gradient. Bởi vì <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1779"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1780">f</span></span></span><script type="math/tex" id="MathJax-Element-252">f</script></span> là một hàm có tham số khả vi, các mô hình PSD có thể được xếp chồng lên nhau và được sử dụng để khởi tạo một mạng đa tầng để được huấn luyện với một mục đích khác.</p><h1 id="149-Ứng-dụng-của-các-bộ-tự-mã-hóa"><a class="anchor hidden-xs" href="#149-Ứng-dụng-của-các-bộ-tự-mã-hóa" title="149-Ứng-dụng-của-các-bộ-tự-mã-hóa"><span class="octicon octicon-link"></span></a>14.9. Ứng dụng của các bộ tự mã hóa.</h1><p>Các bộ tự mã hóa đã được áp dụng thành công trong giảm chiều dữ liệu và các tác vụ truy xuất thông tin. Giảm chiều dữ liệu là một trong những ứng dụng đầu tiên của chủ đề học biểu diễn (representation learning) và học sâu. Nó là một trong những động lực ban đầu để nghiên cứu về các bộ tự mã hóa. Ví dụ, Hinton và Salakhutdinov (2006) đã huấn luyện một tập hợp các RBM theo cấu trúc ngăn xếp và sau đó sử dụng trọng số của chúng để khởi tạo bộ tự mã hóa đa tầng với các lớp ẩn nhỏ dần, xếp chồng lại thành một nút cổ chai có 30 đơn vị. Các đoạn mã được sinh ra có sai số tái thiết thấp hơn so với khi áp dụng phương pháp PCA để giảm chiều dữ liệu về 30, và các biểu diễn học được, một cách định lượng, có thể diễn tả và liên kết các nhóm dễ dàng hơn, và các nhóm này thể hiện các cụm được phân tách tốt.</p><p>Các biểu diễn ở không gian số chiều thấp có thể cải thiện hiệu suất của nhiều tác vụ, chẳng hạn như bộ phân loại. Các mô hình của không gian nhỏ hơn tiêu thụ ít bộ nhớ và thời gian chạy nhanh hơn. Nhiều hình thức giảm kích thước xắp sếp các ví dụ liên quan về mặt ngữ nghĩa đến gần nhau, theo quan sát của Salakhutdinov và Hinton (2007b) và Torralba cùng cộng sự (2008). Những điểm này được gợi ý từ kết quả ánh xạ tới một không gian có số nhiều nhỏ hơn giúp tổng quát hóa.</p><p>Một tác vụ có được lợi ích thậm chí nhiều hơn bình thường từ việc giảm số chiều là tác vụ truy xuất thông tin, nhiệm vụ tìm kiếm các đầu vào trong một cơ sở dữ liệu giống với một đầu vào được truy vấn. Lợi ích của nhiệm vụ này có nguồn gốc từ việc giảm số chiều thông thường cũng như các nhiệm vụ khác thực hiện, nhưng còn thêm vào đó là lợi thế từ việc tìm kiếm có thể trở nên cực kỳ hiệu quả trong một số loại không gian số chiều thấp. Đặc biệt, nếu chúng ta huấn luyện thuật toán giảm số chiều để tạo ra mã chiều thấp và nhị phân, khi đó chúng ta có thể lưu trữ tất cả đầu vào cơ sở dữ liệu trong một bảng băm ánh xạ các vector mã nhị phân ra các đối tượng. Bảng băm này cho phép chúng ta thực hiện truy xuất thông tin bằng cách trả về tất cả các đầu vào cơ sở dữ liệu có cùng một mã nhị phân như truy vấn. Chúng ta cũng có thể tìm kiếm một cách hiệu quả trên các đầu vào gần giống chỉ bằng cách lật (ﬂipping) các bit riêng lẻ từ mã truy vấn. Cách tiếp cận để truy xuất thông tin thông qua giảm số chiều và nhị phân hóa này được gọi là băm ngữ nghĩa (Salakhutdinov và Hinton, 2007b, 2009b) và đã được áp dụng cho cả đầu vào văn bản (Salakhutdinov và Hinton, 2007b, 2009b) và hình ảnh (Torralba <em>et al</em>., 2008; Weiss <em>et al</em>, 2008; Krizhevsky và Hinton, 2011).</p><p>Để tạo mã nhị phân cho băm ngữ nghĩa, mỗi mã thường sử dụng hàm mã hóa hình chữ S ở tầng cuối cùng. Các đơn vị hình chữ S phải được huấn luyện để trở thành phân cực đến gần giá trị <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1781"><span class="MJXp-mn" id="MJXp-Span-1782">0</span></span></span><script type="math/tex" id="MathJax-Element-253">0</script></span> hoặc <span class="mathjax"><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1783"><span class="MJXp-mn" id="MJXp-Span-1784">1</span></span></span><script type="math/tex" id="MathJax-Element-254">1</script></span> cho tất cả các giá trị đầu vào. Một mẹo có thể thực hiện điều này chỉ đơn giản là chèn thêm nhiễu phụ ngay trước hàm phi tuyến hình chữ S trong suốt quá trình huấn luyện. Độ lớn của nhiễu sẽ tăng theo thời gian. Để chống lại nhiễu này và bảo toàn càng nhiều thông tin càng tốt, mạng phải tăng độ lớn của đầu vào của hàm hình chữ S, cho đến khi việc phân cực xảy ra</p><p>Ý tưởng học một hàm băm đã được khám phá thêm trong ở nhiều hướng khác nhau, bao gồm ý tưởng huấn luyện các đại diện để tối ưu hóa tổn thất một cách trực tiếp hơn đến nhiệm vụ tìm kiếm các ví dụ lân cận (nearby examples) trong bảng băm (Norouzivà Fleet, 2011).</p><p>— Thu.Nguyen đã review đến đây —</p><p>---- Trang Le đã review đến đây ----</p></div>
    <div class="ui-toc dropup unselectable hidden-print" style="display:none;">
        <div class="pull-right dropdown">
            <a id="tocLabel" class="ui-toc-label btn btn-default" data-toggle="dropdown" href="#" role="button" aria-haspopup="true" aria-expanded="false" title="Table of content">
                <i class="fa fa-bars"></i>
            </a>
            <ul id="ui-toc" class="ui-toc-dropdown dropdown-menu" aria-labelledby="tocLabel">
                <div class="toc"><ul class="nav">
<li class=""><a href="#Chương-14" title="Chương 14">Chương 14</a></li>
<li><a href="#Chương-14-Bộ-tự-mã-hóa" title="Chương 14
Bộ tự mã hóa">Chương 14
Bộ tự mã hóa</a></li>
<li class=""><a href="#Chapter-14-Bộ-tự-mã-hóa" title="Chapter 14: Bộ tự mã hóa">Chapter 14: Bộ tự mã hóa</a></li>
<li><a href="#141-Các-bộ-tự-mã-hóa-dưới-mức" title="14.1 Các bộ tự mã hóa dưới mức">14.1 Các bộ tự mã hóa dưới mức</a></li>
<li><a href="#142-Bộ-tự-mã-hóa-có-kiểm-soát" title="14.2 Bộ tự mã hóa có kiểm soát">14.2 Bộ tự mã hóa có kiểm soát</a><ul class="nav">
<li><a href="#1421-Bộ-tự-mã-hóa-thưa" title="14.2.1 Bộ tự mã hóa thưa">14.2.1 Bộ tự mã hóa thưa</a></li>
<li><a href="#1422-Bộ-tự-mã-hóa-khử-nhiễu-Denoising-Autoencoders" title="14.2.2 Bộ tự mã hóa khử nhiễu (Denoising Autoencoders)">14.2.2 Bộ tự mã hóa khử nhiễu (Denoising Autoencoders)</a></li>
</ul>
</li>
<li><a href="#1423-Kiểm-soát-bằng-phạt-đạo-hàm" title="14.2.3 Kiểm soát bằng phạt đạo hàm.">14.2.3 Kiểm soát bằng phạt đạo hàm.</a></li>
<li><a href="#143-Bậc-của-biểu-diễn-kích-thước-của-tầng-và-tính-sâu" title="14.3 Bậc của biểu diễn, kích thước của tầng và tính sâu.">14.3 Bậc của biểu diễn, kích thước của tầng và tính sâu.</a></li>
<li><a href="#144-Các-bộ-mã-hóa-và-giải-mã-ngẫu-nhiên" title="14.4 Các bộ mã hóa và giải mã ngẫu nhiên">14.4 Các bộ mã hóa và giải mã ngẫu nhiên</a></li>
<li><a href="#145-Bộ-tự-mã-hóa-khử-nhiễu" title="14.5 Bộ tự mã hóa khử nhiễu">14.5 Bộ tự mã hóa khử nhiễu</a><ul class="nav">
<li class="invisable-node"><ul class="nav">
<li><a href="#1451-Ước-lượng-điểm-số" title="14.5.1 Ước lượng điểm số">14.5.1 Ước lượng điểm số</a></li>
<li><a href="#14511-Bối-cảnh-lịch-sử" title="14.5.1.1 Bối cảnh lịch sử">14.5.1.1 Bối cảnh lịch sử</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#146-Học-đa-tạp-sử-dụng-bộ-tự-mã-hóa" title="14.6 Học đa tạp sử dụng bộ tự mã hóa">14.6 Học đa tạp sử dụng bộ tự mã hóa</a></li>
<li><a href="#147-Bộ-tự-mã-hóa-chèn-ép" title="14.7 Bộ tự mã hóa chèn ép">14.7 Bộ tự mã hóa chèn ép</a></li>
<li><a href="#148-Phân-rã-thưa-tiên-đoán" title="14.8. Phân rã thưa tiên đoán">14.8. Phân rã thưa tiên đoán</a></li>
<li><a href="#149-Ứng-dụng-của-các-bộ-tự-mã-hóa" title="14.9. Ứng dụng của các bộ tự mã hóa.">14.9. Ứng dụng của các bộ tự mã hóa.</a></li>
</ul>
</div><div class="toc-menu"><a class="expand-toggle" href="#">Expand all</a><a class="back-to-top" href="#">Back to top</a><a class="go-to-bottom" href="#">Go to bottom</a></div>
            </ul>
        </div>
    </div>
    <div id="ui-toc-affix" class="ui-affix-toc ui-toc-dropdown unselectable hidden-print" data-spy="affix" style="top:17px;display:none;"  >
        <div class="toc"><ul class="nav">
<li><a href="#Chương-14" title="Chương 14">Chương 14</a></li>
<li class=""><a href="#Chương-14-Bộ-tự-mã-hóa" title="Chương 14
Bộ tự mã hóa">Chương 14
Bộ tự mã hóa</a></li>
<li class=""><a href="#Chapter-14-Bộ-tự-mã-hóa" title="Chapter 14: Bộ tự mã hóa">Chapter 14: Bộ tự mã hóa</a></li>
<li><a href="#141-Các-bộ-tự-mã-hóa-dưới-mức" title="14.1 Các bộ tự mã hóa dưới mức">14.1 Các bộ tự mã hóa dưới mức</a></li>
<li><a href="#142-Bộ-tự-mã-hóa-có-kiểm-soát" title="14.2 Bộ tự mã hóa có kiểm soát">14.2 Bộ tự mã hóa có kiểm soát</a><ul class="nav">
<li><a href="#1421-Bộ-tự-mã-hóa-thưa" title="14.2.1 Bộ tự mã hóa thưa">14.2.1 Bộ tự mã hóa thưa</a></li>
<li><a href="#1422-Bộ-tự-mã-hóa-khử-nhiễu-Denoising-Autoencoders" title="14.2.2 Bộ tự mã hóa khử nhiễu (Denoising Autoencoders)">14.2.2 Bộ tự mã hóa khử nhiễu (Denoising Autoencoders)</a></li>
</ul>
</li>
<li><a href="#1423-Kiểm-soát-bằng-phạt-đạo-hàm" title="14.2.3 Kiểm soát bằng phạt đạo hàm.">14.2.3 Kiểm soát bằng phạt đạo hàm.</a></li>
<li><a href="#143-Bậc-của-biểu-diễn-kích-thước-của-tầng-và-tính-sâu" title="14.3 Bậc của biểu diễn, kích thước của tầng và tính sâu.">14.3 Bậc của biểu diễn, kích thước của tầng và tính sâu.</a></li>
<li><a href="#144-Các-bộ-mã-hóa-và-giải-mã-ngẫu-nhiên" title="14.4 Các bộ mã hóa và giải mã ngẫu nhiên">14.4 Các bộ mã hóa và giải mã ngẫu nhiên</a></li>
<li><a href="#145-Bộ-tự-mã-hóa-khử-nhiễu" title="14.5 Bộ tự mã hóa khử nhiễu">14.5 Bộ tự mã hóa khử nhiễu</a><ul class="nav">
<li class="invisable-node"><ul class="nav">
<li><a href="#1451-Ước-lượng-điểm-số" title="14.5.1 Ước lượng điểm số">14.5.1 Ước lượng điểm số</a></li>
<li><a href="#14511-Bối-cảnh-lịch-sử" title="14.5.1.1 Bối cảnh lịch sử">14.5.1.1 Bối cảnh lịch sử</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#146-Học-đa-tạp-sử-dụng-bộ-tự-mã-hóa" title="14.6 Học đa tạp sử dụng bộ tự mã hóa">14.6 Học đa tạp sử dụng bộ tự mã hóa</a></li>
<li><a href="#147-Bộ-tự-mã-hóa-chèn-ép" title="14.7 Bộ tự mã hóa chèn ép">14.7 Bộ tự mã hóa chèn ép</a></li>
<li><a href="#148-Phân-rã-thưa-tiên-đoán" title="14.8. Phân rã thưa tiên đoán">14.8. Phân rã thưa tiên đoán</a></li>
<li><a href="#149-Ứng-dụng-của-các-bộ-tự-mã-hóa" title="14.9. Ứng dụng của các bộ tự mã hóa.">14.9. Ứng dụng của các bộ tự mã hóa.</a></li>
</ul>
</div><div class="toc-menu"><a class="expand-toggle" href="#">Expand all</a><a class="back-to-top" href="#">Back to top</a><a class="go-to-bottom" href="#">Go to bottom</a></div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.1/jquery.min.js" integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8=" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha256-U5ZEeKfGNOja007MMD3YBI0A3OSZOQbeG6z2f2Y0hu8=" crossorigin="anonymous" defer></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gist-embed/2.6.0/gist-embed.min.js" integrity="sha256-KyF2D6xPIJUW5sUDSs93vWyZm+1RzIpKCexxElmxl8g=" crossorigin="anonymous" defer></script>
    <script>
        var markdown = $(".markdown-body");
        //smooth all hash trigger scrolling
        function smoothHashScroll() {
            var hashElements = $("a[href^='#']").toArray();
            for (var i = 0; i < hashElements.length; i++) {
                var element = hashElements[i];
                var $element = $(element);
                var hash = element.hash;
                if (hash) {
                    $element.on('click', function (e) {
                        // store hash
                        var hash = this.hash;
                        if ($(hash).length <= 0) return;
                        // prevent default anchor click behavior
                        e.preventDefault();
                        // animate
                        $('body, html').stop(true, true).animate({
                            scrollTop: $(hash).offset().top
                        }, 100, "linear", function () {
                            // when done, add hash to url
                            // (default click behaviour)
                            window.location.hash = hash;
                        });
                    });
                }
            }
        }

        smoothHashScroll();
        var toc = $('.ui-toc');
        var tocAffix = $('.ui-affix-toc');
        var tocDropdown = $('.ui-toc-dropdown');
        //toc
        tocDropdown.click(function (e) {
            e.stopPropagation();
        });

        var enoughForAffixToc = true;

        function generateScrollspy() {
            $(document.body).scrollspy({
                target: ''
            });
            $(document.body).scrollspy('refresh');
            if (enoughForAffixToc) {
                toc.hide();
                tocAffix.show();
            } else {
                tocAffix.hide();
                toc.show();
            }
            $(document.body).scroll();
        }

        function windowResize() {
            //toc right
            var paddingRight = parseFloat(markdown.css('padding-right'));
            var right = ($(window).width() - (markdown.offset().left + markdown.outerWidth() - paddingRight));
            toc.css('right', right + 'px');
            //affix toc left
            var newbool;
            var rightMargin = (markdown.parent().outerWidth() - markdown.outerWidth()) / 2;
            //for ipad or wider device
            if (rightMargin >= 133) {
                newbool = true;
                var affixLeftMargin = (tocAffix.outerWidth() - tocAffix.width()) / 2;
                var left = markdown.offset().left + markdown.outerWidth() - affixLeftMargin;
                tocAffix.css('left', left + 'px');
            } else {
                newbool = false;
            }
            if (newbool != enoughForAffixToc) {
                enoughForAffixToc = newbool;
                generateScrollspy();
            }
        }
        $(window).resize(function () {
            windowResize();
        });
        $(document).ready(function () {
            windowResize();
            generateScrollspy();
        });

        //remove hash
        function removeHash() {
            window.location.hash = '';
        }

        var backtotop = $('.back-to-top');
        var gotobottom = $('.go-to-bottom');

        backtotop.click(function (e) {
            e.preventDefault();
            e.stopPropagation();
            if (scrollToTop)
                scrollToTop();
            removeHash();
        });
        gotobottom.click(function (e) {
            e.preventDefault();
            e.stopPropagation();
            if (scrollToBottom)
                scrollToBottom();
            removeHash();
        });

        var toggle = $('.expand-toggle');
        var tocExpand = false;

        checkExpandToggle();
        toggle.click(function (e) {
            e.preventDefault();
            e.stopPropagation();
            tocExpand = !tocExpand;
            checkExpandToggle();
        })

        function checkExpandToggle () {
            var toc = $('.ui-toc-dropdown .toc');
            var toggle = $('.expand-toggle');
            if (!tocExpand) {
                toc.removeClass('expand');
                toggle.text('Expand all');
            } else {
                toc.addClass('expand');
                toggle.text('Collapse all');
            }
        }

        function scrollToTop() {
            $('body, html').stop(true, true).animate({
                scrollTop: 0
            }, 100, "linear");
        }

        function scrollToBottom() {
            $('body, html').stop(true, true).animate({
                scrollTop: $(document.body)[0].scrollHeight
            }, 100, "linear");
        }
    </script>
</body>

</html>
